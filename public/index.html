<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual World</title>
    <!-- THREE.js and GLTF Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Socket.io for real-time communication -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
        }

        /* --- Login Panel Styles --- */
        #loginPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            border: 2px solid #4CAF50;
        }

        #loginPanel input, #loginPanel select {
            padding: 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            width: 200px;
        }

        #loginPanel button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        /* --- Chat Panel Styles --- */
        #chatPanel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            pointer-events: all;
            display: none;
            flex-direction: column;
            justify-content: flex-end;
            z-index: 100;
            border: 1px solid #333;
            transition: height 0.3s ease-in-out, width 0.3s ease-in-out;
        }
        
        #chatPanel.chat-collapsed {
            height: 60px;
        }
        
        #chatPanel.chat-minimal {
            height: 143px;
            width: 300px;
        }
        
        #chatPanel.chat-expanded {
            height: 252px;
        }
        
        #chatHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #chatHeader h3 {
            margin: 0;
        }
        
        #chatToggle {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        #chatMessages {
            overflow-y: auto;
            color: white;
            font-size: 12px;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-grow: 1;
            display: none;
        }
        
        #chatMessages p {
            margin: 0;
            line-height: 1.4;
        }
        
        #chatPanel.chat-expanded #chatMessages,
        #chatPanel.chat-minimal #chatMessages {
            display: block;
        }
        
        #chatPanel.chat-minimal #chatMessages {
            height: 63px;
            flex-grow: 0;
        }
        
        #chatInputContainer {
            display: flex;
            gap: 5px;
            margin-top: auto;
        }
        
        #chatInput {
            flex-grow: 1;
            padding: 5px;
            border: none;
            border-radius: 3px;
        }
        
        #sendButton {
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        
        /* --- D-Pad Styles --- */
        #dpad {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
            z-index: 100;
            grid-template-areas: 
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            opacity: 0.7;
        }
        
        .dpad-button {
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 2px solid rgba(100, 100, 100, 0.8);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        #dpad-up { grid-area: up; }
        #dpad-left { grid-area: left; }
        #dpad-right { grid-area: right; }
        #dpad-down { grid-area: down; }
        
        .dpad-button:active {
            background-color: rgba(100, 100, 100, 0.9);
            border-color: rgba(150, 150, 150, 0.9);
        }

        /* --- UI Styles (General) --- */
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }

        #controls p {
            margin: 0;
            line-height: 1.4;
        }

        #playerList {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        #playerList h3 {
            margin: 0;
        }

        #playerList #playerNames {
            margin-top: 5px;
        }

        #billboardUploadPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 2px solid #4CAF50;
        }

        #billboardUploadPanel h3 {
            margin-top: 0;
        }

        #billboardUploadPanel input[type="file"] {
            margin: 10px 0;
        }

        #billboardUploadPanel button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            z-index: 1001;
            display: none;
            border: 2px solid #4CAF50;
        }

        #loadingMessage .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Mobile Responsive Styles --- */
        @media (max-width: 768px) and (orientation: portrait) {
            #chatPanel {
                width: 250px;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px;
                right: auto;
                padding: 3px;
                box-sizing: border-box;
            }
            #chatPanel.chat-expanded {
                height: 50vh;
            }
            #chatPanel.chat-minimal {
                width: 250px;
                height: 25vh;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                padding: 3px;
            }
            #dpad {
                right: 5px;
                bottom: 5px;
                transform: scale(0.8);
                transform-origin: bottom right;
            }
            #chatInput {
                flex-grow: 1;
                width: 150px; /* Shorter width for input */
            }
            #sendButton {
                width: 80px; /* Narrower width for button */
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #chatPanel {
                width: 25vw;
                left: 5px;
                bottom: 10px;
                right: auto;
                padding: 3px;
            }
            #chatPanel.chat-expanded {
                height: 60vh;
            }
            #chatPanel.chat-minimal {
                width: 25vw;
                height: 40vh;
                left: 5px;
                right: auto;
            }
            #dpad {
                right: 5px;
                bottom: 5px;
                transform: scale(0.8);
                transform-origin: bottom right;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        </div>

    <div id="ui">
        <div id="loginPanel">
            <h2>3D Chat World</h2>
            <input type="text" id="usernameInput" placeholder="Enter username">
            <select id="avatarSelect">
                <option value="selena2">Gomez</option>
                <option value="astronaut">Astro</option>
                <option value="martin2">Shorty</option>
                <option value="cub">King</option>
            </select>
            <button id="joinButton">Join World</button>
        </div>

        <div id="loadingMessage">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>

        <div id="controls">
            <p><strong>Controls</strong></p>
            <p>WASD / Arrows: Move</p>
            <p>Mouse: Look around</p>
            <p>Click on billboards to upload images.</p>
        </div>

        <div id="playerList" style="display: none;">
            <h3>Players Online (<span id="playerCount">0</span>)</h3>
            <div id="playerNames"></div>
        </div>

        <div id="billboardUploadPanel" style="display: none;">
            <h3 id="billboardTitle">Upload Image</h3>
            <input type="file" id="imageFile" accept="image/*">
            <button id="uploadButton">Upload</button>
            <button id="cancelUpload">Cancel</button>
        </div>

        <div id="chatPanel" class="chat-collapsed">
            <div id="chatHeader">
                <h3>Chat</h3>
                <button id="chatToggle">Toggle Chat (Closed)</button>
            </div>
            <div id="chatMessages"></div>
            <div id="chatInputContainer" style="display: none;">
                <input type="text" id="chatInput" placeholder="Type a message...">
                <button id="sendButton">Send</button>
            </div>
        </div>

        <div id="dpad">
            <div class="dpad-button" id="dpad-up">&#9650;</div>
            <div class="dpad-button" id="dpad-left">&#9664;</div>
            <div class="dpad-button" id="dpad-right">&#9654;</div>
            <div class="dpad-button" id="dpad-down">&#9660;</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, socket;
        let avatars = {};
        let myAvatar = null;
        let myUserId = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let billboardMeshes = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentBillboardId = null;
        let isTyping = false;
        let selectedAvatar = 'selena2'; 
        let username = '';
        let gltfLoader = null;
        let avatarMixers = {};
        let clock = new THREE.Clock();
        let loadedGLBModels = {}; // Cache for loaded GLB models

        // Touch control variables
        let touchStartX = 0;
        let touchStartY = 0;
        let isTouching = false;
        const rotationSpeed = 0.005;

        // Avatar positioning and scaling configurations
        const avatarConfigs = {
            'selena2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'astronaut': { 
                scale: 1.0, 
                yOffset: 1.0, 
                rotationOffset: Math.PI/2
            },
            'martin2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'cub': { 
                scale: 1.0, 
                yOffset: 1, 
                rotationOffset: Math.PI 
            }
        };

        // Initialize GLTFLoader after scripts load
        function initGLTFLoader() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
                console.log('GLTFLoader initialized successfully');
            } else {
                console.warn('GLTFLoader not available, some features will be disabled.');
                gltfLoader = null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const usernameInput = document.getElementById('usernameInput');
            const avatarSelect = document.getElementById('avatarSelect');
            const joinButton = document.getElementById('joinButton');
            const sendButton = document.getElementById('sendButton');
            const chatInput = document.getElementById('chatInput');

            // Set the default selection for the dropdown
            avatarSelect.value = selectedAvatar;

            usernameInput.addEventListener('input', () => {
                joinButton.disabled = usernameInput.value.trim() === '';
            });

            joinButton.addEventListener('click', () => {
                username = usernameInput.value.trim();
                selectedAvatar = avatarSelect.value;
                if (username) {
                    document.getElementById('loginPanel').style.display = 'none';
                    document.getElementById('loadingMessage').style.display = 'block';
                    setTimeout(initializeWorld, 500);
                }
            });

            // Ensure the send button works
            sendButton.addEventListener('click', () => {
                sendMessage();
            });

            // Handle enter key to send message
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            usernameInput.focus();
        });

        function initializeWorld() {
            initGLTFLoader();
            if (typeof io !== 'undefined') {
                socket = io();
                initScene();
                setupSocketHandlers();
            } else {
                // Use a message box instead of alert
                showCustomMessage('Socket.io not loaded. Please check your network connection.');
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Add permanent objects to the scene with individual scaling
            // The fourth parameter is a new THREE.Vector3(x, y, z) for the scale.
            // A value of 1 means original size. 2 means twice as big. 0.5 means half size.
            loadPermanentObject('objects/pond.glb', new THREE.Vector3(25, .1, -30), null, new THREE.Vector3(10, 10, 10));
            loadPermanentObject('objects/gazebo.glb', new THREE.Vector3(-25, -.7, 30), new THREE.Vector3(0, Math.PI / 4, 0), new THREE.Vector3(3.5, 3.5, 3.5));
            
            loadSkybox();
            createLighting();
            createGround();
            createTrees();
            createBillboards();
            createMyAvatar();
            setupControls();
            setupTouchControls(); // Initialize new touch controls
            
            // Show UI elements
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('chatPanel').style.display = 'flex';
            
            // Show D-Pad on small screens
            if (window.innerWidth <= 768) {
                document.getElementById('dpad').style.display = 'grid';
            }

            animate();
        }

        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(50, 50, -50);
            directionalLight2.castShadow = false;
            directionalLight2.shadow.mapSize.width = 2048;
            directionalLight2.shadow.mapSize.height = 2048;
            scene.add(directionalLight2);
        }

        function loadSkybox() {
            const skyboxImages = [
                'textures/skybox/px.jpg', 'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg', 'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg', 'textures/skybox/nz.jpg'
            ];
            const loader = new THREE.CubeTextureLoader();
            loader.load(skyboxImages, texture => {
                scene.background = texture;
            }, undefined, error => {
                console.warn('Skybox could not be loaded, using default sky:', error);
            });
        }
        
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'textures/ground_texture.jpg',
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10);
                    const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                },
                undefined,
                (error) => {
                    console.warn('Ground texture could not be loaded, using default color:', error);
                    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                }
            );
        }

        function createTrees() {
            for (let i = 0; i < 15; i++) {
                const tree = new THREE.Group();
                
                // Randomly choose tree type
                const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
                
                if (treeType === 'oak') {
                    // Oak tree - round leaves, thick trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    // Multiple spherical leaf clusters for oak
                    const leafColors = [0x228B22, 0x32CD32, 0x006400];
                    const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                    // Main leaf cluster
                    const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                    const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                    leaves1.position.y = 5.5;
                    leaves1.castShadow = true;
                    tree.add(leaves1);
                    // Additional leaf clusters for fuller look
                    const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves2.position.set(-1.2, 4.8, 0.8);
                    leaves2.castShadow = true;
                    tree.add(leaves2);
                    const leaves3 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves3.position.set(1.5, 5.2, -0.5);
                    leaves3.castShadow = true;
                    tree.add(leaves3);
                } else {
                    // Pine tree - conical shape, thinner trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    // Layered conical sections for pine tree
                    const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                    const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                    // Bottom layer
                    const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                    const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                    cone1.position.y = 5.5;
                    cone1.castShadow = true;
                    tree.add(cone1);
                    // Middle layer
                    const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                    const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                    cone2.position.y = 6.8;
                    cone2.castShadow = true;
                    tree.add(cone2);
                    // Top layer
                    const coneGeometry3 = new THREE.ConeGeometry(1.3, 2);
                    const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                    cone3.position.y = 8;
                    cone3.castShadow = true;
                    tree.add(cone3);
                }
                // Random position (avoid center area)
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 80;
                    z = (Math.random() - 0.5) * 80;
                } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                tree.position.set(x, 0, z);
                tree.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tree);
            }
        }

        function createBillboards() {
            const billboard1Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard1Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const billboard1 = new THREE.Mesh(billboard1Geometry, billboard1Material);
            billboard1.position.set(-15, 5, 0);
            billboard1.castShadow = true;
            billboard1.userData = { billboardId: 'billboard1' };
            billboardMeshes.billboard1 = billboard1;
            scene.add(billboard1);

            const billboard2Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard2Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);
            billboard2.position.set(15, 5, 0);
            billboard2.castShadow = true;
            billboard2.userData = { billboardId: 'billboard2' };
            billboardMeshes.billboard2 = billboard2;
            scene.add(billboard2);
        }

        // New function to load permanent GLB objects
        function loadPermanentObject(objectPath, position, rotation, scale) {
            if (!gltfLoader) {
                console.warn('GLTFLoader not available, cannot load object:', objectPath);
                return;
            }
            gltfLoader.load(
                objectPath,
                (gltf) => {
                    const object = gltf.scene;
                    object.position.copy(position);
                    if (rotation) {
                        object.rotation.copy(rotation);
                    }
                    if (scale) {
                        object.scale.copy(scale);
                    }
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(object);
                },
                undefined,
                (error) => {
                    console.error('An error occurred loading a GLTF model:', error);
                }
            );
        }
        
        // Asynchronous function to create an avatar from a GLB file
        async function createAvatar(userData) {
            return new Promise(async (resolve, reject) => {
                const config = avatarConfigs[userData.avatar];
                if (!config) {
                    console.error('Invalid avatar type:', userData.avatar);
                    return resolve(null);
                }
                
                try {
                    let gltf;
                    if (loadedGLBModels[userData.avatar]) {
                        gltf = loadedGLBModels[userData.avatar];
                    } else {
                        // Dynamically load the GLB file
                        gltf = await new Promise((res, rej) => gltfLoader.load(`avatars/${userData.avatar}.glb`, res, undefined, rej));
                        loadedGLBModels[userData.avatar] = gltf;
                    }
                    
                    const avatar = gltf.scene.clone(); // Use clone to avoid resource conflicts
                    
                    // Avatar properties
                    avatar.userData = { id: userData.id, username: userData.username };
                    avatar.position.set(userData.position.x, userData.position.y, userData.position.z);
                    avatar.rotation.copy(userData.rotation);
                    
                    avatar.scale.set(config.scale, config.scale, config.scale);
                    avatar.position.y += config.yOffset;
                    avatar.rotation.y += config.rotationOffset;
                    
                    // Enable shadows
                    avatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Add animation mixer
                    const mixer = new THREE.AnimationMixer(avatar);
                    avatarMixers[userData.id] = mixer;
                    
                    if (gltf.animations.length > 0) {
                        const action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                    }
                    
                    // Create a text label above the avatar's head
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    const text = userData.username;
                    context.font = 'Bold 18px Arial';
                    const textWidth = context.measureText(text).width;
                    canvas.width = textWidth + 10;
                    canvas.height = 30;
                    context.font = 'Bold 18px Arial';
                    context.fillStyle = 'white';
                    context.fillText(text, 5, 20);

                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(0.1 * textWidth, 0.1 * 30, 1);
                    sprite.position.y = config.yOffset + 1.5; // Position the label above the avatar
                    avatar.add(sprite);

                    resolve(avatar);
                } catch (error) {
                    console.error('Error loading GLTF model for avatar:', userData.avatar, error);
                    resolve(null);
                }
            });
        }

        // Function to create my own avatar
        function createMyAvatar() {
            const config = avatarConfigs[selectedAvatar];
            if (!config || !gltfLoader) {
                // Use a message box instead of alert
                showCustomMessage('Selected avatar model is not available or GLTF Loader is not initialized.');
                return;
            }

            gltfLoader.load(
                `avatars/${selectedAvatar}.glb`,
                (gltf) => {
                    myAvatar = gltf.scene;
                    myAvatar.position.set(0, config.yOffset, 0);
                    myAvatar.scale.set(config.scale, config.scale, config.scale);
                    myAvatar.rotation.y = config.rotationOffset;
                    
                    myAvatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Set up the camera to follow the avatar
                    myAvatar.add(camera);
                    camera.position.set(0, 7, 10);
                    
                    scene.add(myAvatar);

                    myUserId = socket.id;
                    const initialData = {
                        id: myUserId,
                        username: username,
                        avatar: selectedAvatar,
                        position: myAvatar.position,
                        rotation: myAvatar.rotation
                    };
                    socket.emit('user-joined', initialData);
                    
                    // Add animation mixer
                    const mixer = new THREE.AnimationMixer(myAvatar);
                    avatarMixers[myUserId] = mixer;

                    if (gltf.animations.length > 0) {
                        const action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                    }
                },
                undefined,
                (error) => {
                    console.error('Error loading my avatar:', error);
                    // Use a message box instead of alert
                    showCustomMessage('Error loading your avatar model.');
                }
            );
        }

        // Core animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update avatar animations
            const delta = clock.getDelta();
            for (const id in avatarMixers) {
                avatarMixers[id].update(delta);
            }

            // Movement and rotation
            const speed = 0.1;
            const direction = new THREE.Vector3();
            
            const forward = new THREE.Vector3();
            myAvatar.getWorldDirection(forward);
            forward.y = 0; // Prevent movement along the y-axis (up/down)
            forward.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            if (myAvatar) {
                if (moveForward) {
                    myAvatar.position.addScaledVector(forward, speed);
                }
                if (moveBackward) {
                    myAvatar.position.addScaledVector(forward, -speed);
                }
                if (moveLeft) {
                    myAvatar.position.addScaledVector(right, -speed);
                }
                if (moveRight) {
                    myAvatar.position.addScaledVector(right, speed);
                }

                // Send updated position to server
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    socket.emit('user-moved', {
                        userId: myUserId,
                        position: myAvatar.position,
                        rotation: myAvatar.rotation
                    });
                }
            }

            renderer.render(scene, camera);
        }

        function setupControls() {
            // Mouse/Keyboard controls
            const onKeyDown = function (event) {
                if (isTyping) return;
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            };
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse controls for look around
            document.addEventListener('mousemove', (event) => {
                if (!myAvatar) return;
                if (event.buttons === 1) { // Left mouse button
                    const deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    myAvatar.rotation.y -= deltaX * 0.002;
                    socket.emit('user-moved', {
                        userId: myUserId,
                        position: myAvatar.position,
                        rotation: myAvatar.rotation
                    });
                }
            });

            // Billboard click listener
            document.addEventListener('click', onDocumentClick, false);
            
            // D-Pad controls
            document.getElementById('dpad-up').addEventListener('touchstart', (e) => { e.preventDefault(); moveForward = true; });
            document.getElementById('dpad-up').addEventListener('touchend', () => moveForward = false);
            document.getElementById('dpad-down').addEventListener('touchstart', (e) => { e.preventDefault(); moveBackward = true; });
            document.getElementById('dpad-down').addEventListener('touchend', () => moveBackward = false);
            document.getElementById('dpad-left').addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; });
            document.getElementById('dpad-left').addEventListener('touchend', () => moveLeft = false);
            document.getElementById('dpad-right').addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; });
            document.getElementById('dpad-right').addEventListener('touchend', () => moveRight = false);

            document.getElementById('dpad-up').addEventListener('mousedown', () => moveForward = true);
            document.getElementById('dpad-up').addEventListener('mouseup', () => moveForward = false);
            document.getElementById('dpad-down').addEventListener('mousedown', () => moveBackward = true);
            document.getElementById('dpad-down').addEventListener('mouseup', () => moveBackward = false);
            document.getElementById('dpad-left').addEventListener('mousedown', () => moveLeft = true);
            document.getElementById('dpad-left').addEventListener('mouseup', () => moveLeft = false);
            document.getElementById('dpad-right').addEventListener('mousedown', () => moveRight = true);
            document.getElementById('dpad-right').addEventListener('mouseup', () => moveRight = false);

            // Chat input and toggle
            document.getElementById('chatInput').addEventListener('focus', () => isTyping = true);
            document.getElementById('chatInput').addEventListener('blur', () => isTyping = false);

            document.getElementById('chatToggle').addEventListener('click', () => {
                const chatPanel = document.getElementById('chatPanel');
                const chatInputContainer = document.getElementById('chatInputContainer');
                const chatMessages = document.getElementById('chatMessages');
                const chatToggle = document.getElementById('chatToggle');

                if (chatPanel.classList.contains('chat-expanded')) {
                    chatPanel.classList.remove('chat-expanded');
                    chatPanel.classList.add('chat-collapsed');
                    chatInputContainer.style.display = 'none';
                    chatToggle.textContent = 'Toggle Chat (Closed)';
                } else if (chatPanel.classList.contains('chat-collapsed')) {
                    chatPanel.classList.remove('chat-collapsed');
                    chatPanel.classList.add('chat-minimal');
                    chatInputContainer.style.display = 'flex';
                    chatToggle.textContent = 'Toggle Chat (Minimal)';
                } else if (chatPanel.classList.contains('chat-minimal')) {
                    chatPanel.classList.remove('chat-minimal');
                    chatPanel.classList.add('chat-expanded');
                    chatInputContainer.style.display = 'flex';
                    chatToggle.textContent = 'Toggle Chat (Expanded)';
                }
            });

            // Billboard upload panel controls
            document.getElementById('uploadButton').addEventListener('click', () => {
                const fileInput = document.getElementById('imageFile');
                const file = fileInput.files[0];
                if (file && currentBillboardId) {
                    if (file.size > 2 * 1024 * 1024) { // 2 MB limit
                        showCustomMessage('File is too large. Max size is 2MB.');
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const imageData = event.target.result;
                        socket.emit('upload-billboard', {
                            billboardId: currentBillboardId,
                            imageData: imageData
                        });
                        document.getElementById('billboardUploadPanel').style.display = 'none';
                    };
                    reader.readAsDataURL(file);
                } else {
                    showCustomMessage('Please select a file to upload.');
                }
            });

            document.getElementById('cancelUpload').addEventListener('click', () => {
                document.getElementById('billboardUploadPanel').style.display = 'none';
            });
        }
        
        // Function to setup touch controls for rotation
        function setupTouchControls() {
            const gameContainer = document.getElementById('gameContainer');

            gameContainer.addEventListener('touchstart', (event) => {
                // Ignore touch events if the user is interacting with UI elements like the chat panel or d-pad
                const touch = event.touches[0];
                const targetId = event.target.id;
                if (targetId.startsWith('dpad-') || targetId.startsWith('chat') || targetId === 'billboardUploadPanel' || targetId === 'loginPanel') {
                    return;
                }
                
                isTouching = true;
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            }, { passive: false });

            gameContainer.addEventListener('touchmove', (event) => {
                if (!isTouching || !myAvatar) return;
                
                const touch = event.touches[0];
                const deltaX = touch.clientX - touchStartX;
                
                // Rotate the avatar based on horizontal swipe
                myAvatar.rotation.y -= deltaX * rotationSpeed;
                
                // Update touch start position for next frame
                touchStartX = touch.clientX;
                
                // Emit the new rotation to the server
                socket.emit('user-moved', {
                    userId: myUserId,
                    position: myAvatar.position,
                    rotation: myAvatar.rotation
                });
            }, { passive: false });

            gameContainer.addEventListener('touchend', () => {
                isTouching = false;
            });
        }

        // Custom message box function to replace alert()
        function showCustomMessage(message) {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                padding: 20px;
                border-radius: 10px;
                color: white;
                text-align: center;
                z-index: 1002;
                border: 2px solid #4CAF50;
            `;
            messageBox.innerHTML = `<p>${message}</p><button style="margin-top:10px; padding: 5px 10px; background:#4CAF50; color:white; border:none; border-radius:5px;">OK</button>`;
            document.body.appendChild(messageBox);
            messageBox.querySelector('button').addEventListener('click', () => {
                document.body.removeChild(messageBox);
            });
        }

        function onDocumentClick(event) {
            if (isTyping) return;
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections
            const intersects = raycaster.intersectObjects(Object.values(billboardMeshes));
            
            if (intersects.length > 0) {
                // A billboard was clicked
                const intersectedObject = intersects[0].object;
                currentBillboardId = intersectedObject.userData.billboardId;
                document.getElementById('billboardUploadPanel').style.display = 'block';
            }
        }

        function updateBillboard(billboardId, imageData) {
            const billboard = billboardMeshes[billboardId];
            if (billboard) {
                const loader = new THREE.TextureLoader();
                loader.load(imageData, (texture) => {
                    const material = new THREE.MeshLambertMaterial({ map: texture, side: THREE.DoubleSide });
                    billboard.material = material;
                });
            }
        }
        
        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            if (message) {
                socket.emit('chat-message', {
                    userId: myUserId,
                    username: username,
                    message: message
                });
                chatInput.value = '';
            }
        }

        function addChatMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const p = document.createElement('p');
            p.textContent = `${data.username}: ${data.message}`;
            chatMessages.appendChild(p);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to bottom
        }

        function setupSocketHandlers() {
            socket.on('connect', () => {
                console.log('Connected to server with ID:', socket.id);
            });

            socket.on('user-list', async (users) => {
                const playerNamesList = document.getElementById('playerNames');
                playerNamesList.innerHTML = '';
                
                // Add your own name to the list first
                const myNameEl = document.createElement('p');
                myNameEl.textContent = `${username} (You)`;
                playerNamesList.appendChild(myNameEl);

                for (const userId in users) {
                    const userData = users[userId];
                    if (userId === myUserId) continue; // Skip your own user

                    // Add player name to list
                    const playerEl = document.createElement('p');
                    playerEl.textContent = userData.username;
                    playerNamesList.appendChild(playerEl);

                    // Update existing avatar or create new one
                    if (avatars[userData.id]) {
                        const existingAvatar = avatars[userData.id];
                        if (!existingAvatar.position.equals(userData.position)) {
                            existingAvatar.position.set(userData.position.x, (existingAvatar.position.y), userData.position.z);
                            existingAvatar.rotation.copy(userData.rotation);
                        }
                    } else {
                        // Create a new avatar
                        const newAvatar = await createAvatar(userData);
                        if (newAvatar) {
                            avatars[userData.id] = newAvatar;
                            scene.add(newAvatar);
                        }
                    }
                }
                
                document.getElementById('playerCount').textContent = Object.keys(users).length;
                console.log('User list processing complete.');
            });

            socket.on('user-moved', (data) => {
                if (avatars[data.userId]) {
                    avatars[data.userId].position.copy(data.position);
                    avatars[data.userId].rotation.copy(data.rotation);
                }
            });
            socket.on('chat-message', (data) => {
                addChatMessage(data);
            });
            socket.on('billboard-updated', (data) => {
                updateBillboard(data.billboardId, data.imageData);
            });
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

