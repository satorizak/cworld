<script>
    // ... (rest of the file remains the same)

    function createAvatar(userData) {
        console.log(`Creating avatar for user: ${userData.username}, type: ${userData.avatarType || 'default'}`);

        // Prevent duplicate avatar creation
        if (pendingAvatarCreations.has(userData.id)) {
            console.log(`Avatar creation already in progress for ${userData.username}`);
            return avatars[userData.id]; // Return existing avatar if available
        }

        pendingAvatarCreations.add(userData.id);

        const avatarGroup = new THREE.Group();
        avatarGroup.userData.userId = userData.id;
        avatarGroup.userData.username = userData.username;
        avatarGroup.userData.avatarType = userData.avatarType || 'default';

        // Create the username label
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
        context.fillRect(0, 0, 256, 64);
        context.fillStyle = 'white';
        context.font = '24px Arial';
        context.textAlign = 'center';
        context.fillText(userData.username, 128, 40);
        const texture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
        const label = new THREE.Sprite(labelMaterial);
        label.position.y = 3.5;
        label.scale.set(2, 0.5, 1);
        label.userData.isLabel = true;
        avatarGroup.add(label);

        // Load the GLB avatar asynchronously
        loadGLBAvatar(userData.avatarType || 'default', (result) => {
            // Remove any existing avatar mesh (in case this is an update)
            const existingAvatar = avatarGroup.children.find(child => child.userData.isAvatarMesh);
            if (existingAvatar) {
                avatarGroup.remove(existingAvatar);
                // Clean up mixer if it exists
                if (avatarMixers[userData.id]) {
                    avatarMixers[userData.id].stopAllAction();
                    delete avatarMixers[userData.id];
                }
            }

            let avatarMesh;
            if (result && result.avatar) {
                console.log(`Successfully loaded GLB avatar for user: ${userData.username}`);
                avatarMesh = result.avatar;
                avatarMesh.userData.isAvatarMesh = true;

                if (result.mixer) {
                    avatarMixers[userData.id] = result.mixer;
                }
            } else {
                console.log(`Using fallback avatar for user: ${userData.username}`);
                avatarMesh = createFallbackAvatar(userData.color || 0x4CAF50);
                avatarMesh.userData.isAvatarMesh = true;
            }

            avatarGroup.add(avatarMesh);
            pendingAvatarCreations.delete(userData.id);
            console.log(`Avatar creation completed for ${userData.username}`);

            // **MOVED**: Set the position and rotation here, after the avatar mesh is loaded
            avatarGroup.position.set(userData.position.x, Math.max(0, userData.position.y), userData.position.z);
            avatarGroup.rotation.copy(userData.rotation);
        });

        return avatarGroup;
    }

    // ... (rest of the file remains the same)
</script>
