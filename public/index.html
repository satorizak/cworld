<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual World</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
        }

        #loginPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            border: 2px solid #4CAF50;
        }

        #loginPanel input, #loginPanel select {
            padding: 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            width: 200px;
        }

        #loginPanel button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        /* --- Chat Panel Styles --- */
        #chatPanel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            pointer-events: all;
            display: none;
            flex-direction: column;
            justify-content: flex-end;
            z-index: 100;
            border: 1px solid #333;
            transition: height 0.3s ease-in-out, width 0.3s ease-in-out;
        }
        
        #chatPanel.chat-collapsed {
            height: 60px;
        }
        
        #chatPanel.chat-minimal {
            height: 143px;
            width: 300px;
        }
        
        #chatPanel.chat-expanded {
            height: 252px;
        }
        
        #chatHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #chatHeader h3 {
            margin: 0;
        }
        
        #chatToggle {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        #chatMessages {
            overflow-y: auto;
            color: white;
            font-size: 12px;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-grow: 1;
            display: none;
        }
        
        #chatMessages p {
            margin: 0;
            line-height: 1.4;
        }
        
        #chatPanel.chat-expanded #chatMessages,
        #chatPanel.chat-minimal #chatMessages {
            display: block;
        }
        
        #chatPanel.chat-minimal #chatMessages {
            height: 63px;
            flex-grow: 0;
        }
        
        #chatInputContainer {
            display: flex;
            gap: 5px;
            margin-top: auto;
        }
        
        #chatInput {
            flex-grow: 1;
            padding: 5px;
            border: none;
            border-radius: 3px;
        }
        
        #sendButton {
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        
        /* --- D-Pad Styles --- */
        #dpad {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
            z-index: 100;
            grid-template-areas: 
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            opacity: 0.7;
        }
        
        .dpad-button {
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 2px solid rgba(100, 100, 100, 0.8);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        #dpad-up { grid-area: up; }
        #dpad-left { grid-area: left; }
        #dpad-right { grid-area: right; }
        #dpad-down { grid-area: down; }
        
        .dpad-button:active {
            background-color: rgba(100, 100, 100, 0.9);
            border-color: rgba(150, 150, 150, 0.9);
        }

        /* --- UI Styles (General) --- */
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }

        #controls p {
            margin: 0;
            line-height: 1.4;
        }

        #playerList {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        #playerList h3 {
            margin: 0;
        }

        #playerList #playerNames {
            margin-top: 5px;
        }

        #billboardUploadPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 2px solid #4CAF50;
        }

        #billboardUploadPanel h3 {
            margin-top: 0;
        }

        #billboardUploadPanel input[type="file"] {
            margin: 10px 0;
        }

        #billboardUploadPanel button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            z-index: 1001;
            display: none;
            border: 2px solid #4CAF50;
        }

        #loadingMessage .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Mobile Responsive Styles --- */
        @media (max-width: 768px) and (orientation: portrait) {
            #chatPanel {
                width: 25vw;
                left: 5px;
                bottom: 10px;
                right: auto;
                padding: 3px;
                box-sizing: border-box;
            }
            #chatPanel.chat-expanded {
                height: 50vh;
            }
            #chatPanel.chat-minimal {
                width: 25vw;
                height: 25vh;
                left: 5px;
                right: auto;
                padding: 3px;
            }
            #dpad {
                right: 5px;
                bottom: 5px;
                transform: scale(0.8);
                transform-origin: bottom right;
            }
            /* MODIFICATION 1: Adjust chat input and send button for portrait view */
            #chatInputContainer {
                width: 80%;
                margin: 0 auto;
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #chatPanel {
                width: 25vw;
                left: 5px;
                bottom: 10px;
                right: auto;
                padding: 3px;
            }
            #chatPanel.chat-expanded {
                height: 60vh;
            }
            #chatPanel.chat-minimal {
                width: 25vw;
                height: 40vh;
                left: 5px;
                right: auto;
            }
            #dpad {
                right: 5px;
                bottom: 5px;
                transform: scale(0.8);
                transform-origin: bottom right;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        </div>

    <div id="ui">
        <div id="loginPanel">
            <h2>3D Chat World</h2>
            <input type="text" id="usernameInput" placeholder="Enter username">
            <select id="avatarSelect">
                <option value="selena2">Gomez</option>
                <option value="astronaut">Astro</option>
                <option value="martin2">Shorty</option>
                <option value="cub">King</option>
            </select>
            <button id="joinButton">Join World</button>
        </div>

        <div id="loadingMessage">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>

        <div id="controls">
            <p><strong>Controls</strong></p>
            <p>WASD / Arrows: Move</p>
            <p>Mouse: Look around</p>
            <p>Click on billboards to upload images.</p>
        </div>

        <div id="playerList" style="display: none;">
            <h3>Players Online (<span id="playerCount">0</span>)</h3>
            <div id="playerNames"></div>
        </div>

        <div id="billboardUploadPanel" style="display: none;">
            <h3 id="billboardTitle">Upload Image</h3>
            <input type="file" id="imageFile" accept="image/*">
            <button id="uploadButton">Upload</button>
            <button id="cancelUpload">Cancel</button>
        </div>

        <div id="chatPanel" class="chat-collapsed">
            <div id="chatHeader">
                <h3>Chat</h3>
                <button id="chatToggle">Toggle Chat (Closed)</button>
            </div>
            <div id="chatMessages"></div>
            <div id="chatInputContainer" style="display: none;">
                <input type="text" id="chatInput" placeholder="Type a message...">
                <button id="sendButton">Send</button>
            </div>
        </div>

        <div id="dpad">
            <div class="dpad-button" id="dpad-up">&#9650;</div>
            <div class="dpad-button" id="dpad-left">&#9664;</div>
            <div class="dpad-button" id="dpad-right">&#9654;</div>
            <div class="dpad-button" id="dpad-down">&#9660;</div>
        </div>

    </div>

    <script>
        // Global variables
        let scene, camera, renderer, socket;
        let avatars = {};
        let myAvatar = null;
        let myUserId = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let billboardMeshes = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentBillboardId = null;
        let isTyping = false;
        let selectedAvatar = 'selena2'; 
        let username = '';
        let gltfLoader = null;
        let avatarMixers = {};
        let clock = new THREE.Clock();
        let loadedGLBModels = {}; // Cache for loaded GLB models

        // MODIFICATION 2: Variables for touch rotation
        let touchRotating = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let currentCameraRotationX = 0;

        // Avatar positioning and scaling configurations
        const avatarConfigs = {
            'selena2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'astronaut': { 
                scale: 1.0, 
                yOffset: 1.0, 
                rotationOffset: Math.PI/2
            },
            'martin2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'cub': { 
                scale: 1.0, 
                yOffset: 1, 
                rotationOffset: Math.PI 
            }
        };

        // Initialize GLTFLoader after scripts load
        function initGLTFLoader() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
                console.log('GLTFLoader initialized successfully');
            } else {
                console.warn('GLTFLoader not available, some features will be disabled.');
                gltfLoader = null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const usernameInput = document.getElementById('usernameInput');
            const avatarSelect = document.getElementById('avatarSelect');
            const joinButton = document.getElementById('joinButton');

            // Set the default selection for the dropdown
            avatarSelect.value = selectedAvatar;

            usernameInput.addEventListener('input', () => {
                joinButton.disabled = usernameInput.value.trim() === '';
            });

            joinButton.addEventListener('click', () => {
                username = usernameInput.value.trim();
                selectedAvatar = avatarSelect.value;
                if (username) {
                    document.getElementById('loginPanel').style.display = 'none';
                    document.getElementById('loadingMessage').style.display = 'block';
                    setTimeout(initializeWorld, 500);
                }
            });

            usernameInput.focus();
        });

        function initializeWorld() {
            initGLTFLoader();
            if (typeof io !== 'undefined') {
                socket = io();
                initScene();
                setupSocketHandlers();
            } else {
                // Using a custom modal instead of alert
                showModal('Socket.io not loaded. Please check your network connection.');
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            loadPermanentObject('objects/pond.glb', new THREE.Vector3(25, .1, -30), null, new THREE.Vector3(10, 10, 10));
            loadPermanentObject('objects/gazebo.glb', new THREE.Vector3(-25, -.7, 30), new THREE.Vector3(0, Math.PI / 4, 0), new THREE.Vector3(3.5, 3.5, 3.5));
            
            loadSkybox();
            createLighting();
            createGround();
            createTrees();
            createBillboards();
            createMyAvatar();
            setupControls();
            
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('chatPanel').style.display = 'flex';
            
            if (window.innerWidth <= 768) {
                document.getElementById('dpad').style.display = 'grid';
            }

            animate();
        }

        function createBillboards() {
            const billboardPositions = [
                new THREE.Vector3(-15, 6, -30),
                new THREE.Vector3(15, 6, -30)
            ];

            const billboardSize = { width: 15, height: 8 };

            billboardPositions.forEach((pos, index) => {
                const billboardId = `billboard-${index}`;
                
                const geometry = new THREE.PlaneGeometry(billboardSize.width, billboardSize.height);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    side: THREE.DoubleSide,
                    map: new THREE.TextureLoader().load(`https://placehold.co/${billboardSize.width * 100}x${billboardSize.height * 100}/000000/FFFFFF?text=Click+to+upload`) 
                });
                
                const billboard = new THREE.Mesh(geometry, material);
                billboard.position.copy(pos);
                billboard.lookAt(new THREE.Vector3(0, pos.y, 0));
                billboard.userData = { id: billboardId, type: 'billboard' };

                const standGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
                const standMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const stand = new THREE.Mesh(standGeometry, standMaterial);
                stand.position.set(pos.x, pos.y - 5, pos.z);
                stand.castShadow = true;

                scene.add(billboard);
                scene.add(stand);
                billboardMeshes[billboardId] = billboard;
            });
        }
        
        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(50, 50, -50);
            directionalLight2.castShadow = false;
            directionalLight2.shadow.mapSize.width = 2048;
            directionalLight2.shadow.mapSize.height = 2048;
            scene.add(directionalLight2);
        }

        function loadSkybox() {
            const skyboxImages = [
                'textures/skybox/px.jpg', 'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg', 'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg', 'textures/skybox/nz.jpg'
            ];
            const loader = new THREE.CubeTextureLoader();
            loader.load(skyboxImages, texture => {
                scene.background = texture;
            }, undefined, error => {
                console.warn('Skybox could not be loaded, using default sky:', error);
            });
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'textures/ground_texture.jpg',
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10);
                    const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                },
                undefined,
                (error) => {
                    console.warn('Ground texture could not be loaded, using default color:', error);
                    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                }
            );
        }

        function createTrees() {
            for (let i = 0; i < 15; i++) {
                const tree = new THREE.Group();
                const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
                if (treeType === 'oak') {
                    const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    const leafColors = [0x228B22, 0x32CD32, 0x006400];
                    const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                    const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                    const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                    leaves1.position.y = 5.5;
                    leaves1.castShadow = true;
                    tree.add(leaves1);
                    const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves2.position.set(-1.2, 4.8, 0.8);
                    leaves2.castShadow = true;
                    tree.add(leaves2);
                    const leaves3Geometry = new THREE.SphereGeometry(1.8);
                    const leaves3Material = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves3Mesh = new THREE.Mesh(leaves3Geometry, leaves3Material);
                    leaves3Mesh.position.set(1.5, 5.2, -0.5);
                    leaves3Mesh.castShadow = true;
                    tree.add(leaves3Mesh);
                } else {
                    const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                    const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                    const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                    const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                    cone1.position.y = 5.5;
                    cone1.castShadow = true;
                    tree.add(cone1);
                    const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                    const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                    cone2.position.y = 6.8;
                    cone2.castShadow = true;
                    tree.add(cone2);
                    const coneGeometry3 = new THREE.ConeGeometry(1.4, 2);
                    const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                    cone3.position.y = 7.8;
                    cone3.castShadow = true;
                    tree.add(cone3);
                }
                tree.position.set(Math.random() * 80 - 40, 0, Math.random() * 80 - 40);
                scene.add(tree);
            }
        }

        function createMyAvatar() {
            loadGLBModel(selectedAvatar).then(model => {
                myAvatar = model;
                if(myAvatar){
                    const config = avatarConfigs[selectedAvatar];
                    myAvatar.position.y = config.yOffset;
                    myAvatar.rotation.y = config.rotationOffset;
                    myAvatar.scale.set(config.scale, config.scale, config.scale);
                    scene.add(myAvatar);
                    camera.position.set(myAvatar.position.x, myAvatar.position.y + 2, myAvatar.position.z + 5);
                }
            }).catch(e => {
                console.error("Failed to load my avatar:", e);
                const geometry = new THREE.BoxGeometry(1, 2, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                myAvatar = new THREE.Mesh(geometry, material);
                myAvatar.position.y = 1;
                scene.add(myAvatar);
                camera.position.set(myAvatar.position.x, myAvatar.position.y + 2, myAvatar.position.z + 5);
            });
        }

        function setupControls() {
            // Mouse lock for camera control
            document.addEventListener('click', (event) => {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(Object.values(billboardMeshes));
                
                if (intersects.length > 0) {
                    const billboard = intersects[0].object;
                    const billboardId = billboard.userData.id;
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            if (file.size > 2 * 1024 * 1024) { // 2MB limit
                                showModal('Image size exceeds 2MB limit.', 'Error');
                                return;
                            }
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                const imageData = event.target.result;
                                if (socket) {
                                    socket.emit('update-billboard', { billboardId, imageData });
                                }
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    fileInput.click();
                } else if (document.pointerLockElement !== renderer.domElement) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                } else {
                }
            });
            
            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === renderer.domElement) {
                    myAvatar.rotation.y -= event.movementX * 0.002;
                    camera.rotation.x -= event.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });

            // Keyboard controls for computer view
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = false;
                        break;
                }
            });

            // D-pad touch controls
            document.getElementById('dpad-up').addEventListener('touchstart', (e) => { e.preventDefault(); moveForward = true; });
            document.getElementById('dpad-up').addEventListener('touchend', (e) => { e.preventDefault(); moveForward = false; });
            document.getElementById('dpad-down').addEventListener('touchstart', (e) => { e.preventDefault(); moveBackward = true; });
            document.getElementById('dpad-down').addEventListener('touchend', (e) => { e.preventDefault(); moveBackward = false; });
            document.getElementById('dpad-left').addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; });
            document.getElementById('dpad-left').addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; });
            document.getElementById('dpad-right').addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; });
            document.getElementById('dpad-right').addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; });

            // MODIFICATION 2: Touch-based rotation controls
            renderer.domElement.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent default browser behavior like scrolling
                if (event.touches.length === 1) {
                    touchRotating = true;
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    currentCameraRotationX = camera.rotation.x;
                }
            });

            renderer.domElement.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (touchRotating) {
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    // Rotate the avatar around the Y-axis based on horizontal swipe
                    myAvatar.rotation.y -= deltaX * 0.005; // Adjust sensitivity as needed
                    
                    // Rotate the camera up/down based on vertical swipe
                    camera.rotation.x = currentCameraRotationX - deltaY * 0.005; // Adjust sensitivity
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                touchRotating = false;
            });
        }

        function setupSocketHandlers() {
            socket.on('connect', () => {
                myUserId = socket.id;
                console.log('Connected to server with ID:', myUserId);
                socket.emit('join-world', { username: username, avatar: selectedAvatar });
            });

            socket.on('user-list', (users) => {
                const playerNamesList = document.getElementById('playerNames');
                playerNamesList.innerHTML = '';
                let playerCount = 0;

                for (const id in avatars) {
                    if (!users[id]) {
                        scene.remove(avatars[id]);
                        delete avatars[id];
                    }
                }
                
                for (const id in users) {
                    if (id !== myUserId) {
                        playerCount++;
                        const userData = users[id];
                        if (!avatars[id]) {
                            loadGLBModel(userData.avatar).then(model => {
                                if(model){
                                    const config = avatarConfigs[userData.avatar];
                                    model.position.copy(userData.position);
                                    model.rotation.copy(userData.rotation);
                                    model.position.y = config.yOffset;
                                    model.scale.set(config.scale, config.scale, config.scale);
                                    avatars[id] = model;
                                    scene.add(model);
                                    const mixer = new THREE.AnimationMixer(model);
                                    avatarMixers[id] = mixer;
                                    if(model.animations && model.animations.length > 0) {
                                        const action = mixer.clipAction(model.animations[0]);
                                        action.play();
                                    }
                                }
                            }).catch(e => {
                                console.error(`Failed to load avatar for user ${id}:`, e);
                            });
                        } else {
                            const existingAvatar = avatars[id];
                            existingAvatar.position.copy(userData.position);
                            existingAvatar.rotation.copy(userData.rotation);
                        }
                    }
                    const name = userData.username;
                    const nameElement = document.createElement('p');
                    nameElement.textContent = name;
                    playerNamesList.appendChild(nameElement);
                }
                document.getElementById('playerCount').textContent = playerCount;
            });
            
            socket.on('user-moved', (data) => {
                if (avatars[data.userId]) {
                    avatars[data.userId].position.copy(data.position);
                    avatars[data.userId].rotation.copy(data.rotation);
                }
            });

            socket.on('chat-message', (data) => {
                const chatMessages = document.getElementById('chatMessages');
                const messageElement = document.createElement('p');
                messageElement.textContent = `${data.username}: ${data.message}`;
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });

            socket.on('billboard-updated', (data) => {
                const billboard = billboardMeshes[data.billboardId];
                if (billboard) {
                    const loader = new THREE.TextureLoader();
                    loader.load(data.imageData, texture => {
                        const oldTexture = billboard.material.map;
                        if(oldTexture) oldTexture.dispose();
                        billboard.material.map = texture;
                        billboard.material.needsUpdate = true;
                        const aspectRatio = texture.image.width / texture.image.height;
                        const planeAspectRatio = billboard.geometry.parameters.width / billboard.geometry.parameters.height;
                        if (aspectRatio > planeAspectRatio) {
                            texture.repeat.set(planeAspectRatio / aspectRatio, 1);
                            texture.offset.x = (1 - planeAspectRatio / aspectRatio) / 2;
                            texture.offset.y = 0;
                        } else {
                            texture.repeat.set(1, aspectRatio / planeAspectRatio);
                            texture.offset.x = 0;
                            texture.offset.y = (1 - aspectRatio / planeAspectRatio) / 2;
                        }
                    });
                }
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (!myAvatar) return;

            const delta = clock.getDelta();
            if (myAvatar) {
                for (const id in avatarMixers) {
                    avatarMixers[id].update(delta);
                }
            }

            const moveDirection = new THREE.Vector3();
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            myAvatar.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (moveForward) moveDirection.add(forward);
            if (moveBackward) moveDirection.sub(forward);
            if (moveLeft) moveDirection.sub(right);
            if (moveRight) moveDirection.add(right);

            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                myAvatar.position.add(moveDirection.multiplyScalar(velocity.x * delta));
                socket.emit('update-position', { position: myAvatar.position, rotation: myAvatar.rotation });
            }

            const offset = new THREE.Vector3(0, 2, 5);
            offset.applyQuaternion(myAvatar.quaternion);
            camera.position.copy(myAvatar.position).add(offset);
            camera.lookAt(myAvatar.position.x, myAvatar.position.y + 1, myAvatar.position.z);

            renderer.render(scene, camera);
        }

        function loadGLBModel(fileName) {
            return new Promise((resolve, reject) => {
                if (loadedGLBModels[fileName]) {
                    resolve(loadedGLBModels[fileName].clone());
                    return;
                }
                const loader = gltfLoader;
                loader.load(
                    `avatars/${fileName}.glb`,
                    (gltf) => {
                        const model = gltf.scene;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        loadedGLBModels[fileName] = model;
                        resolve(model.clone());
                    },
                    undefined,
                    (error) => {
                        console.error('An error happened loading the GLB model:', error);
                        reject(error);
                    }
                );
            });
        }

        function showModal(message, title = 'Message') {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                padding: 20px;
                border-radius: 10px;
                color: white;
                text-align: center;
                z-index: 2000;
                pointer-events: all;
                border: 2px solid #4CAF50;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            `;
            modal.innerHTML = `<h3>${title}</h3><p>${message}</p><button onclick="this.parentNode.remove()">OK</button>`;
            document.body.appendChild(modal);
        }

        function loadPermanentObject(modelPath, position, rotation, scale) {
            if (!gltfLoader) {
                console.warn("GLTFLoader not initialized, cannot load permanent object.");
                return;
            }
            gltfLoader.load(modelPath, function(gltf) {
                const object = gltf.scene;
                object.position.copy(position);
                if (rotation) {
                    object.rotation.copy(rotation);
                }
                if (scale) {
                    object.scale.copy(scale);
                }
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scene.add(object);
            }, undefined, function(error) {
                console.error('An error happened loading a permanent object:', error);
            });
        }
    </script>
</body>
</html>

