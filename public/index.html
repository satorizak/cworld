<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual World</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
        }

        #loginPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            border: 2px solid #4CAF50;
        }

        #loginPanel input, #loginPanel select {
            padding: 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            width: 200px;
        }

        #loginPanel button {
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        /* --- Chat Panel Styles --- */
        #chatPanel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 25vw;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            pointer-events: all;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            z-index: 100;
            border: 1px solid #333;
            transition: height 0.3s ease-in-out;
        }
        
        #chatPanel.chat-collapsed {
            height: 60px;
        }
        
        #chatPanel.chat-minimal {
            height: 143px;
        }
        
        #chatPanel.chat-expanded {
            height: 252px;
        }
        
        #chatHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #chatHeader h3 {
            margin: 0;
        }
        
        #chatToggle {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        #chatMessages {
            overflow-y: auto;
            color: white;
            font-size: 12px;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-grow: 1;
            display: none;
        }
        
        #chatMessages p {
            margin: 0;
            line-height: 1.4;
        }
        
        #chatPanel.chat-expanded #chatMessages,
        #chatPanel.chat-minimal #chatMessages {
            display: block;
        }
        
        #chatPanel.chat-minimal #chatMessages {
            height: 63px;
            flex-grow: 0;
        }
        
        #chatInputContainer {
            display: flex;
            gap: 5px;
            margin-top: auto;
        }
        
        #chatInput {
            flex-grow: 1;
            padding: 5px;
            border: none;
            border-radius: 3px;
        }
        
        #sendButton {
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        /* --- D-Pad Styles --- */
        #dpad {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
            z-index: 100;
            grid-template-areas: 
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            opacity: 0.7;
        }
        
        .dpad-button {
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 2px solid rgba(100, 100, 100, 0.8);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        #dpad-up { grid-area: up; }
        #dpad-left { grid-area: left; }
        #dpad-right { grid-area: right; }
        #dpad-down { grid-area: down; }
        
        .dpad-button:active {
            background-color: rgba(100, 100, 100, 0.9);
            border-color: rgba(150, 150, 150, 0.9);
        }

        /* --- UI Styles (General) --- */
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }

        #controls p {
            margin: 0;
            line-height: 1.4;
        }

        #playerList {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        #playerList h3 {
            margin: 0;
        }

        #playerList #playerNames {
            margin-top: 5px;
        }

        #billboardUploadPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            pointer-events: all;
            color: white;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 2px solid #4CAF50;
        }

        #billboardUploadPanel h3 {
            margin-top: 0;
        }

        #billboardUploadPanel input[type="file"] {
            margin: 10px 0;
        }

        #billboardUploadPanel button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            z-index: 1001;
            display: none;
            border: 2px solid #4CAF50;
        }

        #loadingMessage .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* --- Mobile Responsive Styles --- */
        @media (max-width: 768px) and (orientation: portrait) {
            #chatPanel {
                width: 80vw;
                left: 50%;
                bottom: 10px;
                right: auto;
                transform: translateX(-50%);
                padding: 3px;
                box-sizing: border-box;
            }
            #chatPanel.chat-expanded {
                height: 50vh;
            }
            #chatPanel.chat-minimal {
                height: 30vh;
                width: 80vw;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                padding: 3px;
            }
            #chatInputContainer {
                flex-direction: column;
                gap: 5px;
            }
            #sendButton {
                width: 100%;
            }
            #dpad {
                right: 5px;
                bottom: 5px;
                transform: scale(0.8);
                transform-origin: bottom right;
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #chatPanel {
                width: 25vw;
                left: 5px;
                bottom: 10px;
                right: auto;
                padding: 3px;
            }
            #chatPanel.chat-expanded {
                height: 60vh;
            }
            #chatPanel.chat-minimal {
                width: 25vw;
                height: 40vh;
                left: 5px;
                right: auto;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        </div>

    <div id="ui">
        <div id="loginPanel">
            <h2>3D Chat World</h2>
            <input type="text" id="usernameInput" placeholder="Enter username">
            <select id="avatarSelect">
                <option value="selena2">Gomez</option>
                <option value="astronaut">Astro</option>
                <option value="martin2">Shorty</option>
                <option value="cub">King</option>
            </select>
            <button id="joinButton">Join World</button>
        </div>

        <div id="loadingMessage">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>

        <div id="controls">
            <p><strong>Controls</strong></p>
            <p>WASD / Arrows: Move</p>
            <p>Click + Drag: Look around</p>
            <p>Click on billboards to upload images.</p>
            <p>Touch & drag on screen to look around (mobile)</p>
        </div>

        <div id="playerList" style="display: none;">
            <h3>Players Online (<span id="playerCount">0</span>)</h3>
            <div id="playerNames"></div>
        </div>

        <div id="billboardUploadPanel" style="display: none;">
            <h3 id="billboardTitle">Upload Image</h3>
            <input type="file" id="imageFile" accept="image/*">
            <button id="uploadButton">Upload</button>
            <button id="cancelUpload">Cancel</button>
        </div>

        <div id="chatPanel" class="chat-minimal">
            <div id="chatHeader">
                <h3>Chat</h3>
                <button id="chatToggle">Toggle Chat</button>
            </div>
            <div id="chatMessages"></div>
            <div id="chatInputContainer">
                <input type="text" id="chatInput" placeholder="Type a message...">
                <button id="sendButton">Send</button>
            </div>
        </div>

        <div id="dpad">
            <div class="dpad-button" id="dpad-up">&#9650;</div>
            <div class="dpad-button" id="dpad-left">&#9664;</div>
            <div class="dpad-button" id="dpad-right">&#9654;</div>
            <div class="dpad-button" id="dpad-down">&#9660;</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, socket;
        let avatars = {};
        let myAvatar = null;
        let myUserId = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let billboardMeshes = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentBillboardId = null;
        let isTyping = false;
        let isLooking = false; // New flag for mouse rotation
        let selectedAvatar = 'selena2'; 
        let username = '';
        let gltfLoader = null;
        let avatarMixers = {};
        let clock = new THREE.Clock();
        let loadedGLBModels = {}; // Cache for loaded GLB models
        
        // New variables for touch rotation controls
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Avatar positioning and scaling configurations
        const avatarConfigs = {
            'selena2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'astronaut': { 
                scale: 1.0, 
                yOffset: 1.0, 
                rotationOffset: Math.PI/2
            },
            'martin2': { 
                scale: 1.0, 
                yOffset: 1.2, 
                rotationOffset: Math.PI 
            },
            'cub': { 
                scale: 1.0, 
                yOffset: 1, 
                rotationOffset: Math.PI 
            }
        };

        // Initialize GLTFLoader after scripts load
        function initGLTFLoader() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
            } else {
                console.warn('GLTFLoader not available, some features will be disabled.');
                gltfLoader = null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const usernameInput = document.getElementById('usernameInput');
            const avatarSelect = document.getElementById('avatarSelect');
            const joinButton = document.getElementById('joinButton');

            // Set the default selection for the dropdown
            avatarSelect.value = selectedAvatar;

            // Initially disable the join button until a username is entered
            joinButton.disabled = usernameInput.value.trim() === '';

            usernameInput.addEventListener('input', () => {
                joinButton.disabled = usernameInput.value.trim() === '';
            });

            joinButton.addEventListener('click', () => {
                username = usernameInput.value.trim();
                selectedAvatar = avatarSelect.value;
                if (username) {
                    document.getElementById('loginPanel').style.display = 'none';
                    document.getElementById('loadingMessage').style.display = 'block';
                    setTimeout(initializeWorld, 500);
                }
            });

            usernameInput.focus();
        });

        function initializeWorld() {
            initGLTFLoader();
            if (typeof io !== 'undefined') {
                socket = io();
                initScene();
                setupSocketHandlers();
            } else {
                showCustomMessage('Socket.io not loaded. Please check your network connection.');
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            loadPermanentObject('objects/pond.glb', new THREE.Vector3(25, .1, -30), null, new THREE.Vector3(10, 10, 10));
            loadPermanentObject('objects/gazebo.glb', new THREE.Vector3(-25, -.7, 30), new THREE.Vector3(0, Math.PI / 4, 0), new THREE.Vector3(3.5, 3.5, 3.5));
            
            loadSkybox();
            createLighting();
            createGround();
            createTrees();
            createBillboards();
            createMyAvatar();
            setupControls();
            
            // Show UI elements
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('chatPanel').style.display = 'flex';
            
            // Show D-Pad on small screens
            if (window.innerWidth <= 768) {
                document.getElementById('dpad').style.display = 'grid';
            }

            animate();
        }

        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(50, 50, -50);
            directionalLight2.castShadow = false;
            directionalLight2.shadow.mapSize.width = 2048;
            directionalLight2.shadow.mapSize.height = 2048;
            scene.add(directionalLight2);
        }

        function loadSkybox() {
            const skyboxImages = [
                'textures/skybox/px.jpg', 'textures/skybox/nx.jpg',
                'textures/skybox/py.jpg', 'textures/skybox/ny.jpg',
                'textures/skybox/pz.jpg', 'textures/skybox/nz.jpg'
            ];
            const loader = new THREE.CubeTextureLoader();
            loader.load(skyboxImages, texture => {
                scene.background = texture;
            }, undefined, error => {
                console.warn('Skybox could not be loaded, using default sky:', error);
            });
        }
        
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'textures/ground_texture.jpg',
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10);
                    const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                },
                undefined,
                (error) => {
                    console.warn('Ground texture could not be loaded, using default color:', error);
                    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                }
            );
        }

        function createTrees() {
            for (let i = 0; i < 15; i++) {
                const tree = new THREE.Group();
                const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
                
                if (treeType === 'oak') {
                    const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    
                    const leafColors = [0x228B22, 0x32CD32, 0x006400];
                    const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                    const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                    const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                    leaves1.position.y = 5.5;
                    leaves1.castShadow = true;
                    tree.add(leaves1);
                    const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves2.position.set(-1.2, 4.8, 0.8);
                    leaves2.castShadow = true;
                    tree.add(leaves2);
                    const leavesGeometry3 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial3 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves3 = new THREE.Mesh(leavesGeometry3, leavesMaterial3);
                    leaves3.position.set(1.5, 5.2, -0.5);
                    leaves3.castShadow = true;
                    tree.add(leaves3);
                } else {
                    const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                    const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                    const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                    const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                    cone1.position.y = 5.5;
                    cone1.castShadow = true;
                    tree.add(cone1);
                    const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                    const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                    cone2.position.y = 6.8;
                    cone2.castShadow = true;
                    tree.add(cone2);
                    const coneGeometry3 = new THREE.ConeGeometry(1.3, 2);
                    const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                    cone3.position.y = 8;
                    cone3.castShadow = true;
                    tree.add(cone3);
                }
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 80;
                    z = (Math.random() - 0.5) * 80;
                } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                tree.position.set(x, 0, z);
                tree.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tree);
            }
        }

        function createBillboards() {
            const billboard1Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard1Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const billboard1 = new THREE.Mesh(billboard1Geometry, billboard1Material);
            billboard1.position.set(-15, 5, 0);
            billboard1.castShadow = true;
            billboard1.userData = { billboardId: 'billboard1' };
            billboardMeshes.billboard1 = billboard1;
            scene.add(billboard1);
            const billboard2Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard2Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);
            billboard2.position.set(15, 5, 0);
            billboard2.castShadow = true;
            billboard2.userData = { billboardId: 'billboard2' };
            billboardMeshes.billboard2 = billboard2;
            scene.add(billboard2);
        }

        function loadPermanentObject(objectPath, position, rotation, scale) {
            if (!gltfLoader) {
                console.warn('GLTFLoader not available, cannot load object:', objectPath);
                return;
            }
            gltfLoader.load(
                objectPath,
                (gltf) => {
                    const object = gltf.scene;
                    object.position.copy(position);
                    if (rotation) {
                        object.rotation.set(rotation.x, rotation.y, rotation.z);
                    }
                    if (scale) {
                        object.scale.copy(scale);
                    }
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(object);
                },
                (xhr) => {},
                (error) => {
                    console.error('An error occurred loading the GLB file:', error);
                }
            );
        }
        
        async function createAvatar(userData) {
            if (!gltfLoader) {
                return;
            }
            // Check cache first
            if (loadedGLBModels[userData.avatar]) {
                const model = loadedGLBModels[userData.avatar].clone();
                return positionAvatar(model, userData);
            }
            const avatarPath = `avatars/${userData.avatar}.glb`;
            try {
                const gltf = await gltfLoader.loadAsync(avatarPath);
                const model = gltf.scene;
                // Cache the loaded model
                loadedGLBModels[userData.avatar] = model;
                return positionAvatar(model.clone(), userData);
            } catch (error) {
                console.error('An error occurred loading the GLB file:', error);
                return null;
            }
        }
        
        function positionAvatar(avatar, userData) {
            const config = avatarConfigs[userData.avatar];
            if (config) {
                avatar.scale.set(config.scale, config.scale, config.scale);
                avatar.position.y = config.yOffset;
                if (config.rotationOffset) {
                    avatar.rotation.y = config.rotationOffset;
                }
            }
            avatar.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return avatar;
        }

        function createMyAvatar() {
            if (!gltfLoader) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                myAvatar = new THREE.Mesh(geometry, material);
                myAvatar.position.y = 0.5;
                scene.add(myAvatar);
                camera.position.set(0, 1.6, -3);
                myAvatar.add(camera);
                
                socket.emit('join', {
                    username: username,
                    avatar: 'fallback-cube',
                    position: myAvatar.position,
                    rotation: myAvatar.rotation
                });
                return;
            }
            gltfLoader.load(
                `avatars/${selectedAvatar}.glb`,
                (gltf) => {
                    myAvatar = gltf.scene;
                    const config = avatarConfigs[selectedAvatar];
                    if (config) {
                        myAvatar.scale.set(config.scale, config.scale, config.scale);
                        myAvatar.position.y = config.yOffset;
                        if (config.rotationOffset) {
                            myAvatar.rotation.y = config.rotationOffset;
                        }
                    }
                    myAvatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(myAvatar);
                    camera.position.set(0, 1.6, -3);
                    myAvatar.add(camera);
                    
                    socket.emit('join', {
                        username: username,
                        avatar: selectedAvatar,
                        position: myAvatar.position,
                        rotation: myAvatar.rotation
                    });
                },
                (xhr) => {},
                (error) => {
                    console.error('An error occurred loading the GLB file:', error);
                    // Fallback to a simple cube if GLB fails to load
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                    myAvatar = new THREE.Mesh(geometry, material);
                    myAvatar.position.y = 0.5;
                    scene.add(myAvatar);
                    camera.position.set(0, 1.6, -3);
                    myAvatar.add(camera);
                    
                    socket.emit('join', {
                        username: username,
                        avatar: 'fallback-cube',
                        position: myAvatar.position,
                        rotation: myAvatar.rotation
                    });
                }
            );
        }
        
        function setupControls() {
            // New mouse event listeners for rotation
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.addEventListener('touchstart', onTouchStartGame, { passive: false });
            gameContainer.addEventListener('touchmove', onTouchMoveGame, { passive: false });
            gameContainer.addEventListener('touchend', onTouchEndGame, { passive: false });

            document.getElementById('chatInput').addEventListener('focus', () => { 
                isTyping = true;
            });
            document.getElementById('chatInput').addEventListener('blur', () => { 
                isTyping = false;
            });
            document.getElementById('chatInput').addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    sendMessage();
                }
            });
            document.getElementById('sendButton').addEventListener('click', sendMessage);
            document.getElementById('chatToggle').addEventListener('click', toggleChat);
            document.getElementById('uploadButton').addEventListener('click', handleImageUpload);
            document.getElementById('cancelUpload').addEventListener('click', () => {
                document.getElementById('billboardUploadPanel').style.display = 'none';
                currentBillboardId = null;
            });
            const dpadButtons = document.querySelectorAll('.dpad-button');
            dpadButtons.forEach(button => {
                button.addEventListener('touchstart', onTouchStartDpad, { passive: false });
                button.addEventListener('touchend', onTouchEndDpad, { passive: false });
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (window.innerWidth <= 768) {
                    document.getElementById('dpad').style.display = 'grid';
                } else {
                    document.getElementById('dpad').style.display = 'none';
                }
            });
        }
        
        function onTouchStartDpad(event) {
            event.preventDefault();
            const buttonId = event.target.id;
            switch (buttonId) {
                case 'dpad-up':
                    moveForward = true;
                    break;
                case 'dpad-down':
                    moveBackward = true;
                    break;
                case 'dpad-left':
                    moveLeft = true;
                    break;
                case 'dpad-right':
                    moveRight = true;
                    break;
            }
        }
        
        function onTouchEndDpad(event) {
            event.preventDefault();
            const buttonId = event.target.id;
            switch (buttonId) {
                case 'dpad-up':
                    moveForward = false;
                    break;
                case 'dpad-down':
                    moveBackward = false;
                    break;
                case 'dpad-left':
                    moveLeft = false;
                    break;
                case 'dpad-right':
                    moveRight = false;
                    break;
            }
        }
        
        function onTouchStartGame(event) {
            if (event.touches.length === 1 && !isTyping) {
                isDragging = true;
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;
            }
        }

        function onTouchMoveGame(event) {
            if (isDragging && myAvatar) {
                event.preventDefault();
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                const deltaX = touchX - lastTouchX;
                const deltaY = touchY - lastTouchY;
                myAvatar.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                lastTouchX = touchX;
                lastTouchY = touchY;
            }
        }

        function onTouchEndGame(event) {
            isDragging = false;
        }

        function onKeyDown(event) {
            if (isTyping) return;
            switch (event.key) {
                case 'w':
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 's':
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'a':
                case 'ArrowLeft':
                    moveLeft = true;
                    break;
                case 'd':
                case 'ArrowRight':
                    moveRight = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.key) {
                case 'w':
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 's':
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'a':
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'd':
                case 'ArrowRight':
                    moveRight = false;
                    break;
            }
        }

        // New mouse event handlers for controlled rotation
        function onMouseDown(event) {
            if (event.button === 0) { // Left mouse button
                isLooking = true;
                document.getElementById('gameContainer').style.cursor = 'grabbing';
            }
            // Raycast for billboard interaction
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(billboardMeshes));
            if (intersects.length > 0) {
                const billboardId = intersects[0].object.userData.billboardId;
                if (billboardId) {
                    currentBillboardId = billboardId;
                    document.getElementById('billboardTitle').textContent = `Upload to ${billboardId}`;
                    document.getElementById('billboardUploadPanel').style.display = 'block';
                }
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isLooking = false;
                document.getElementById('gameContainer').style.cursor = 'grab';
            }
        }

        function onMouseMove(event) {
            if (isLooking && myAvatar) {
                const deltaX = event.movementX || 0;
                const deltaY = event.movementY || 0;
                myAvatar.rotation.y -= deltaX * 0.002;
                camera.rotation.x -= deltaY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function updateBillboard(billboardId, imageData) {
            if (billboardMeshes[billboardId]) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageData, (texture) => {
                    const material = new THREE.MeshLambertMaterial({ map: texture, side: THREE.DoubleSide });
                    billboardMeshes[billboardId].material = material;
                }, undefined, (error) => {
                    console.error('Failed to load image for billboard:', error);
                    billboardMeshes[billboardId].material.color.set(0xff0000);
                });
            }
        }
        
        function handleImageUpload() {
            const fileInput = document.getElementById('imageFile');
            const file = fileInput.files[0];
            if (file && currentBillboardId) {
                const maxSize = 2 * 1024 * 1024;
                if (file.size > maxSize) {
                    showCustomMessage("File size exceeds the 2MB limit.", "Error");
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(event) {
                    const imageData = event.target.result;
                    socket.emit('update-billboard', { billboardId: currentBillboardId, imageData });
                    document.getElementById('billboardUploadPanel').style.display = 'none';
                    currentBillboardId = null;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function showCustomMessage(message, title = "Message") {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9); color: white; padding: 20px; border-radius: 10px;
                z-index: 2000; text-align: center; border: 2px solid #4CAF50;
            `;
            messageBox.innerHTML = `
                <h3>${title}</h3>
                <p>${message}</p>
                <button onclick="this.parentNode.remove()" style="padding: 10px; margin-top: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px;">OK</button>
            `;
            document.body.appendChild(messageBox);
        }

        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            if (message !== '' && socket) {
                socket.emit('chat-message', { message: message, username: username });
                chatInput.value = '';
                // The blur event will handle the resizing
                chatInput.blur();
            }
        }
        
        function addChatMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('p');
            messageElement.textContent = `${data.username}: ${data.message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function toggleChat() {
            const chatPanel = document.getElementById('chatPanel');
            
            if (chatPanel.classList.contains('chat-minimal')) {
                chatPanel.classList.remove('chat-minimal');
                chatPanel.classList.add('chat-expanded');
            } else if (chatPanel.classList.contains('chat-expanded')) {
                chatPanel.classList.remove('chat-expanded');
                chatPanel.classList.add('chat-minimal');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (myAvatar) {
                const speed = 5;
                velocity.set(0, 0, 0);
                if (!isTyping) {
                    if (moveForward) velocity.z -= speed;
                    if (moveBackward) velocity.z += speed;
                    if (moveLeft) velocity.x -= speed;
                    if (moveRight) velocity.x += speed;
                }
                const direction = new THREE.Vector3(velocity.x, 0, velocity.z);
                direction.applyQuaternion(myAvatar.quaternion);
                myAvatar.position.addScaledVector(direction, delta);
                const boundary = 45;
                myAvatar.position.x = Math.max(-boundary, Math.min(boundary, myAvatar.position.x));
                myAvatar.position.z = Math.max(-boundary, Math.min(boundary, myAvatar.position.z));
                socket.emit('move', {
                    position: myAvatar.position,
                    rotation: myAvatar.rotation
                });
            }
            for (const id in avatarMixers) {
                avatarMixers[id].update(delta);
            }
            renderer.render(scene, camera);
        }
        
        function setupSocketHandlers() {
            socket.on('connect', () => {
                console.log('Connected to server');
            });

            socket.on('user-list', async (userList) => {
                const users = userList;
                const connectedUsers = new Set(Object.keys(users));
                
                // Clear the player list UI
                const playerNames = document.getElementById('playerNames');
                playerNames.innerHTML = '';
                
                // Update or remove avatars
                for (const userId in avatars) {
                    if (!connectedUsers.has(userId) || userId === socket.id) {
                        scene.remove(avatars[userId]);
                        delete avatars[userId];
                        if (avatarMixers[userId]) {
                             delete avatarMixers[userId];
                        }
                    }
                }
                
                // Create or update avatars and player list UI
                for (const userId in users) {
                    const userData = users[userId];
                    const p = document.createElement('p');
                    p.textContent = userData.username;
                    playerNames.appendChild(p);

                    if (userId === socket.id) continue;
                    
                    if (avatars[userId]) {
                        // Update existing avatar position and rotation
                        const existingAvatar = avatars[userId];
                        existingAvatar.position.set(userData.position.x, userData.position.y, userData.position.z);
                        existingAvatar.rotation.copy(userData.rotation);
                    } else {
                        // Create a new avatar
                        const newAvatar = await createAvatar(userData);
                        if (newAvatar) {
                            avatars[userId] = newAvatar;
                            scene.add(newAvatar);
                            newAvatar.position.copy(userData.position);
                            newAvatar.rotation.copy(userData.rotation);
                        }
                    }
                }
                document.getElementById('playerCount').textContent = Object.keys(users).length;
            });

            socket.on('user-moved', (data) => {
                if (avatars[data.userId]) {
                    avatars[data.userId].position.copy(data.position);
                    avatars[data.userId].rotation.copy(data.rotation);
                }
            });
            
            socket.on('user-left', (userId) => {
                if (avatars[userId]) {
                    scene.remove(avatars[userId]);
                    delete avatars[userId];
                }
                const playerNames = document.getElementById('playerNames');
                const userElements = playerNames.getElementsByTagName('p');
                for (let i = 0; i < userElements.length; i++) {
                    if (userElements[i].textContent.includes(userId)) { // assuming username is unique
                        playerNames.removeChild(userElements[i]);
                        break;
                    }
                }
            });

            socket.on('chat-message', (data) => {
                addChatMessage(data);
            });
            
            socket.on('billboard-updated', (data) => {
                updateBillboard(data.billboardId, data.imageData);
            });
        }
    </script>
</body>
</html>

