<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chat World</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåç</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }

        /* Startup Screen Styles */
        #startup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            color: white;
        }

        .startup-container {
            background: #222;
            padding: 30px;
            border: 2px solid #444;
            border-radius: 8px;
            text-align: center;
            min-width: 350px;
        }

        .startup-container h1 {
            color: white;
            margin: 0 0 25px 0;
            font-size: 2em;
            font-weight: normal;
        }

        .startup-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            width: 100%;
            text-align: left;
        }

        .form-group label {
            color: white;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-input, .form-select {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            background: #333;
            color: white;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #777;
        }

        .start-button {
            padding: 12px 30px;
            background: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 10px;
            min-width: 150px;
        }

        .start-button:hover {
            background: #666;
        }

        .start-button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            /* Update for responsive chat width */
            width: 90%; 
            max-width: 400px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
            pointer-events: all;
            transition: height 0.3s ease, opacity 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        /* Media query for chat width on larger screens (20% of viewport width) */
        @media (min-width: 769px) {
            #chat-container {
                max-width: 20vw;
            }
        }

        #chat-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            pointer-events: all;
            z-index: 1001;
        }

        #chat-toggle:hover {
            background: #0056b3;
        }

        #chat-messages {
            flex-grow: 1;
            height: 220px;
            overflow-y: auto;
            color: white;
            font-size: 12px;
            margin-bottom: 10px;
            border: 1px solid #333;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
            transition: height 0.3s ease, opacity 0.3s ease;
        }

        #chat-input {
            display: flex;
            gap: 5px;
            transition: opacity 0.3s ease;
        }

        #message-input {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
        }

        #send-button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #send-button:hover {
            background: #0056b3;
        }
        
        #chat-container.collapsed #chat-messages,
        #chat-container.collapsed #chat-input {
            height: 0;
            padding: 0;
            margin: 0;
            opacity: 0;
            overflow: hidden;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            pointer-events: all;
            font-size: 12px;
        }

        #controls h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        #controls p {
            margin: 3px 0;
        }

        /* NEW D-Pad styles */
        #dpad-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 180px;
            display: none; /* Hidden by default */
            pointer-events: all;
        }

        #dpad-container button {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        #dpad-up { top: 0; left: 60px; }
        #dpad-left { top: 60px; left: 0; }
        #dpad-right { top: 60px; left: 120px; }
        #dpad-down { top: 60px; left: 60px; }
        
        /* Media query to display D-pad on mobile */
        @media (max-width: 768px) {
            #dpad-container {
                display: block;
            }
            #controls {
                display: none; /* Hide desktop controls on mobile */
            }
        }
        
        /* Ensure the chat container doesn't overlap the D-pad */
        @media (max-width: 768px) {
            #chat-container {
                bottom: 200px; /* Adjust based on D-pad size */
                left: 50%;
                transform: translateX(-50%);
            }
        }

        #upload-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            pointer-events: all;
            z-index: 2000;
            min-width: 400px;
            text-align: center;
        }

        #upload-modal h3 {
            margin-top: 0;
            color: #fff;
        }

        .file-input {
            margin: 15px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            border: 2px solid #444;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .upload-button, .cancel-button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .upload-button {
            background: #28a745;
            color: white;
        }

        .upload-button:hover {
            background: #1e7e34;
        }

        .upload-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .cancel-button {
            background: #dc3545;
            color: white;
        }

        .cancel-button:hover {
            background: #c82333;
        }

        .system-message {
            color: #ffeb3b;
            font-style: italic;
        }

        .user-message {
            color: #ffffff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="startup-screen">
        <div class="startup-container">
            <h1>3D Chat World</h1>
            <div class="startup-form">
                <div class="form-group">
                    <label for="username-input">Username:</label>
                    <input type="text" id="username-input" class="form-input" placeholder="Enter your username..." maxlength="20">
                </div>
                
                <div class="form-group">
                    <label for="avatar-select">Avatar:</label>
                    <select id="avatar-select" class="form-select">
                        <option value="default">Default</option>
                        <option value="male">Male</option>
                        <option value="female">Female</option>
                    </select>
                </div>
                
                <button class="start-button" id="start-world-btn">Join World</button>
            </div>
        </div>
    </div>
    
    <div id="loading" style="display: none;">Loading 3D World...</div>
    
    <div id="ui" style="display: none;">
        <div id="controls">
            <h3>Controls</h3>
            <p>WASD/Arrows: Move</p>
            <p>Mouse: Look around</p>
            <p>Click billboards to upload</p>
            <p>Users online: <span id="user-count">1</span></p>
        </div>

        <div id="dpad-container">
            <button id="dpad-up">‚ñ≤</button>
            <button id="dpad-down">‚ñº</button>
            <button id="dpad-left">‚óÄ</button>
            <button id="dpad-right">‚ñ∂</button>
        </div>

        <div id="upload-modal">
            <h3 id="modal-title">Upload Image to Billboard</h3>
            <p>Select an image (max 2MB):</p>
            <input type="file" id="modal-file-input" class="file-input" accept="image/*">
            <div class="modal-buttons">
                <button class="upload-button" id="modal-upload-btn">Upload</button>
                <button class="cancel-button" id="modal-cancel-btn">Cancel</button>
            </div>
        </div>

        <div id="chat-container">
            <button id="chat-toggle">Hide</button>
            <div id="chat-messages"></div>
            <div id="chat-input">
                <input type="text" id="message-input" placeholder="Type your message..." maxlength="200">
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, socket;
        let avatars = {};
        let myAvatar = null;
        let myUserId = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let billboardMeshes = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentBillboardId = null;
        let isTyping = false;
        let selectedAvatar = 'default';
        let username = '';
        let gltfLoader = null;
        let avatarMixers = {};
        let clock = new THREE.Clock();
        
        // Avatar scale configuration - adjust individual avatar sizes
        const avatarScales = {
            'default': 1.0,
            'male': 1.0,
            'female': 1.0
            // Add more avatars here later, e.g.:
            // 'astronaut': 2.0,  // 2x bigger
            // 'lion': 0.5        // Half size
        };
        
        // Initialize GLTFLoader after scripts load
        function initGLTFLoader() {
            if (typeof THREE.GLTFLoader !== 'undefined') {
                gltfLoader = new THREE.GLTFLoader();
                console.log('GLTFLoader initialized successfully');
            } else {
                console.warn('GLTFLoader not available, using fallback avatars');
                gltfLoader = null;
            }
        }
        
        // Startup screen handlers
        document.addEventListener('DOMContentLoaded', () => {
            const avatarSelect = document.getElementById('avatar-select');
            const usernameInput = document.getElementById('username-input');
            const startButton = document.getElementById('start-world-btn');
            
            // Avatar selection
            avatarSelect.addEventListener('change', () => {
                selectedAvatar = avatarSelect.value;
            });
            
            // Username validation
            usernameInput.addEventListener('input', validateForm);
            usernameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    startWorld();
                }
            });
            
            // Start button
            startButton.addEventListener('click', startWorld);
            
            function validateForm() {
                const username = usernameInput.value.trim();
                startButton.disabled = username.length < 1;
            }
            
            function startWorld() {
                username = usernameInput.value.trim();
                if (username.length < 1) {
                    alert('Please enter a username');
                    return;
                }
                
                // Hide startup screen and show loading
                document.getElementById('startup-screen').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                
                // Initialize the 3D world
                setTimeout(initializeWorld, 500);
            }
            
            // Set focus to username input
            usernameInput.focus();
        });
        
        function initializeWorld() {
            // Initialize GLTFLoader first
            initGLTFLoader();
            
            // Initialize socket connection and wait for it
            if (typeof io !== 'undefined') {
                socket = io();
                console.log('Socket.io initialized');
                
                // Initialize Three.js scene after socket is ready
                initScene();
            } else {
                console.error('Socket.io not loaded');
                alert('Connection failed - Socket.io not available');
            }
        }
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Load skybox
            loadSkybox();
            
            // Improved lighting for better billboard visibility
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Light 2
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(50, 50, -50);
            directionalLight2.castShadow = false;
            directionalLight2.shadow.mapSize.width = 2048;
            directionalLight2.shadow.mapSize.height = 2048;
            scene.add(directionalLight2);
            
            // Create ground with texture
            createGround();
            
            // Create trees
            createTrees();
            
            // Create billboards
            createBillboards();
            
            // Create my avatar
            createMyAvatar();
            
            // Setup controls
            setupControls();
            
            // Start render loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
        }

        function loadSkybox() {
            const skyboxImages = [
                'textures/skybox/px.jpg', // positive x
                'textures/skybox/nx.jpg', // negative x
                'textures/skybox/py.jpg', // positive y
                'textures/skybox/ny.jpg', // negative y
                'textures/skybox/pz.jpg', // positive z
                'textures/skybox/nz.jpg'  // negative z
            ];
            
            const loader = new THREE.CubeTextureLoader();
            
            loader.load(
                skyboxImages,
                (texture) => {
                    scene.background = texture;
                    console.log('Skybox loaded successfully');
                },
                undefined,
                (error) => {
                    console.warn('Skybox could not be loaded, using default sky:', error);
                    // Keep the default blue sky color
                }
            );
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            
            // Try to load ground texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'textures/ground_texture.jpg',
                (texture) => {
                    // Success - use texture
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10); // Repeat texture for better coverage
                    
                    const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                    console.log('Ground texture loaded successfully');
                },
                undefined,
                (error) => {
                    // Error - use default color
                    console.warn('Ground texture could not be loaded, using default color:', error);
                    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.rotation.x = -Math.PI / 2;
                    ground.receiveShadow = true;
                    scene.add(ground);
                }
            );
        }

        function createTrees() {
            for (let i = 0; i < 15; i++) {
                const tree = new THREE.Group();
                
                // Randomly choose tree type
                const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
                
                if (treeType === 'oak') {
                    // Oak tree - round leaves, thick trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    
                    // Multiple spherical leaf clusters for oak
                    const leafColors = [0x228B22, 0x32CD32, 0x006400];
                    const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                    
                    // Main leaf cluster
                    const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                    const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                    leaves1.position.y = 5.5;
                    leaves1.castShadow = true;
                    tree.add(leaves1);
                    
                    // Additional leaf clusters for fuller look
                    const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves2.position.set(-1.2, 4.8, 0.8);
                    leaves2.castShadow = true;
                    tree.add(leaves2);
                    
                    const leaves3 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves3.position.set(1.5, 5.2, -0.5);
                    leaves3.castShadow = true;
                    tree.add(leaves3);
                    
                } else {
                    // Pine tree - conical shape, thinner trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    
                    // Layered conical sections for pine tree
                    const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                    const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                    
                    // Bottom layer
                    const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                    const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                    cone1.position.y = 5.5;
                    cone1.castShadow = true;
                    tree.add(cone1);
                    
                    // Middle layer
                    const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                    const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                    cone2.position.y = 6.8;
                    cone2.castShadow = true;
                    tree.add(cone2);
                    
                    // Top layer
                    const coneGeometry3 = new THREE.ConeGeometry(1.3, 2);
                    const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                    cone3.position.y = 8;
                    cone3.castShadow = true;
                    tree.add(cone3);
                }
                
                // Random position (avoid center area)
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 80;
                    z = (Math.random() - 0.5) * 80;
                } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                
                tree.position.set(x, 0, z);
                tree.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tree);
            }
        }
        
        function createBillboards() {
            const billboard1Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard1Material = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const billboard1 = new THREE.Mesh(billboard1Geometry, billboard1Material);
            billboard1.position.set(-15, 5, 0);
            billboard1.castShadow = true;
            billboard1.userData = { billboardId: 'billboard1' };
            billboardMeshes.billboard1 = billboard1;
            scene.add(billboard1);
            
            const billboard2Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard2Material = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);
            billboard2.position.set(15, 5, 0);
            billboard2.castShadow = true;
            billboard2.userData = { billboardId: 'billboard2' };
            billboardMeshes.billboard2 = billboard2;
            scene.add(billboard2);
        }
        
        function loadGLBAvatar(avatarType, callback) {
            if (!gltfLoader) {
                console.warn('GLTFLoader not available, using fallback avatar');
                callback(null);
                return;
            }
            
            const avatarPath = `avatars/${avatarType}.glb`;
            
            gltfLoader.load(
                avatarPath,
                (gltf) => {
                    const avatar = gltf.scene;
                    
                    // Get custom scale multiplier for this avatar type
                    const scaleMultiplier = avatarScales[avatarType] || 1.0;
                    
                    // Scale avatar to appropriate size with custom multiplier
                    const box = new THREE.Box3().setFromObject(avatar);
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const targetHeight = 2.5; // Base target height
                    const scale = (targetHeight / maxSize) * scaleMultiplier;
                    
                    avatar.scale.set(scale, scale, scale);
                    
                    // Center avatar
                    box.setFromObject(avatar);
                    const center = box.getCenter(new THREE.Vector3());
                    avatar.position.sub(center);
                    
                    // Enable shadows
                    avatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Setup animations if available
                    let mixer = null;
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(avatar);
                        const idleAnimation = gltf.animations.find(anim => 
                            anim.name.toLowerCase().includes('idle') || 
                            anim.name.toLowerCase().includes('stand')
                        );
                        
                        if (idleAnimation) {
                            const action = mixer.clipAction(idleAnimation);
                            action.play();
                        }
                    }
                    
                    console.log(`GLB avatar ${avatarType} loaded successfully with scale ${scaleMultiplier}`);
                    callback({ avatar, mixer });
                },
                undefined,
                (error) => {
                    console.warn(`Failed to load GLB avatar ${avatarType}:`, error);
                    callback(null);
                }
            );
        }
        
        function createFallbackAvatar(color = 0x4CAF50) {
            const avatar = new THREE.Group();
            
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            avatar.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.4);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;
            head.castShadow = true;
            avatar.add(head);
            
            return avatar;
        }
        
        function createMyAvatar() {
            loadGLBAvatar(selectedAvatar, (result) => {
                if (result && result.avatar) {
                    // Use GLB avatar
                    myAvatar = new THREE.Group();
                    myAvatar.add(result.avatar);
                    
                    if (result.mixer) {
                        avatarMixers[myUserId] = result.mixer;
                    }
                } else {
                    // Use fallback avatar
                    myAvatar = createFallbackAvatar();
                }
                
                myAvatar.position.set(0, 0, 0);
                scene.add(myAvatar);
                updateCameraPosition();
            });
        }
        
        function createAvatar(userData) {
            const avatarGroup = new THREE.Group();
            
            loadGLBAvatar(userData.avatarType || 'default', (result) => {
                let avatar;
                
                if (result && result.avatar) {
                    // Use GLB avatar
                    avatar = result.avatar.clone();
                    
                    if (result.mixer) {
                        const mixer = new THREE.AnimationMixer(avatar);
                        avatarMixers[userData.id] = mixer;
                        
                        // Find and play idle animation
                        const gltf = result.avatar.userData.gltf;
                        if (gltf && gltf.animations) {
                            const idleAnimation = gltf.animations.find(anim => 
                                anim.name.toLowerCase().includes('idle') || 
                                anim.name.toLowerCase().includes('stand')
                            );
                            
                            if (idleAnimation) {
                                const action = mixer.clipAction(idleAnimation);
                                action.play();
                            }
                        }
                    }
                } else {
                    // Use fallback avatar
                    avatar = createFallbackAvatar(userData.color);
                }
                
                avatarGroup.add(avatar);
                
                // Create name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'white';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(userData.username, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const label = new THREE.Sprite(labelMaterial);
                label.position.y = 3.5;
                label.scale.set(2, 0.5, 1);
                avatarGroup.add(label);
            });
            
            avatarGroup.position.set(userData.position.x, Math.max(0, userData.position.y), userData.position.z);
            avatarGroup.rotation.copy(userData.rotation);
            
            return avatarGroup;
        }
        
        function setupControls() {
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('focus', () => { isTyping = true; });
            messageInput.addEventListener('blur', () => { isTyping = false; });
            
            document.addEventListener('keydown', (event) => {
                if (isTyping) return;
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp': moveForward = true; break;
                    case 'KeyS':
                    case 'ArrowDown': moveBackward = true; break;
                    case 'KeyA':
                    case 'ArrowLeft': moveLeft = true; break;
                    case 'KeyD':
                    case 'ArrowRight': moveRight = true; break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                if (isTyping) return;
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp': moveForward = false; break;
                    case 'KeyS':
                    case 'ArrowDown': moveBackward = false; break;
                    case 'KeyA':
                    case 'ArrowLeft': moveLeft = false; break;
                    case 'KeyD':
                    case 'ArrowRight': moveRight = false; break;
                }
            });
            
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousedown', (event) => {
                if (event.target === renderer.domElement) {
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            document.addEventListener('mouseup', (event) => {
                if (isMouseDown && event.target === renderer.domElement) {
                    const deltaX = Math.abs(event.clientX - mouseX);
                    const deltaY = Math.abs(event.clientY - mouseY);
                    
                    if (deltaX < 5 && deltaY < 5) {
                        handleBillboardClick(event);
                    }
                }
                isMouseDown = false;
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown && myAvatar) {
                    const deltaX = event.clientX - mouseX;
                    myAvatar.rotation.y -= deltaX * 0.005;
                    updateCameraPosition();
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            document.getElementById('modal-upload-btn').addEventListener('click', handleModalUpload);
            document.getElementById('modal-cancel-btn').addEventListener('click', closeUploadModal);
            document.getElementById('send-button').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keypress', (event) => {
                if (event.key === 'Enter') sendMessage();
            });
            document.getElementById('chat-toggle').addEventListener('click', toggleChat);

            // NEW D-Pad Event Handlers for Mobile
            const dpadUp = document.getElementById('dpad-up');
            const dpadDown = document.getElementById('dpad-down');
            const dpadLeft = document.getElementById('dpad-left');
            const dpadRight = document.getElementById('dpad-right');

            dpadUp.addEventListener('touchstart', (e) => { e.preventDefault(); moveForward = true; });
            dpadUp.addEventListener('touchend', (e) => { e.preventDefault(); moveForward = false; });
            dpadDown.addEventListener('touchstart', (e) => { e.preventDefault(); moveBackward = true; });
            dpadDown.addEventListener('touchend', (e) => { e.preventDefault(); moveBackward = false; });
            dpadLeft.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; });
            dpadLeft.addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; });
            dpadRight.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; });
            dpadRight.addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; });
        }
        
        function updateMovement() {
            if (!myAvatar) return;
            
            const speed = 0.2;
            velocity.set(0, 0, 0);
            
            if (moveForward) velocity.z -= speed;
            if (moveBackward) velocity.z += speed;
            if (moveLeft) velocity.x += speed;
            if (moveRight) velocity.x -= speed;
            
            if (velocity.length() > 0) {
                const direction = new THREE.Vector3();
                myAvatar.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(direction, camera.up);
                
                const oldPosition = myAvatar.position.clone();
                
                myAvatar.position.add(direction.multiplyScalar(-velocity.z));
                myAvatar.position.add(right.multiplyScalar(-velocity.x));
                myAvatar.position.y = Math.max(0, myAvatar.position.y);
                
                updateCameraPosition();
                
                if (oldPosition.distanceTo(myAvatar.position) > 0.01 && socket && socket.connected) {
                    socket.emit('user-moved', {
                        position: {
                            x: myAvatar.position.x,
                            y: myAvatar.position.y,
                            z: myAvatar.position.z
                        },
                        rotation: {
                            x: myAvatar.rotation.x,
                            y: myAvatar.rotation.y,
                            z: myAvatar.rotation.z
                        }
                    });
                }
            }
        }
        
        function updateCameraPosition() {
            if (!myAvatar) return;
            
            const avatarPosition = myAvatar.position.clone();
            const avatarRotation = myAvatar.rotation.y;
            
            const cameraDistance = 5;
            const cameraHeight = 2;
            
            const cameraX = avatarPosition.x - Math.sin(avatarRotation) * cameraDistance;
            const cameraZ = avatarPosition.z - Math.cos(avatarRotation) * cameraDistance;
            const cameraY = avatarPosition.y + cameraHeight;
            
            camera.position.set(cameraX, cameraY, cameraZ);
            
            const lookAtPoint = new THREE.Vector3(
                avatarPosition.x,
                avatarPosition.y + 1.5,
                avatarPosition.z
            );
            camera.lookAt(lookAtPoint);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // Update avatar animations
            Object.values(avatarMixers).forEach(mixer => {
                if (mixer) mixer.update(deltaTime);
            });
            
            updateMovement();
            renderer.render(scene, camera);
        }
        
        function toggleChat() {
            const chatContainer = document.getElementById('chat-container');
            const toggleButton = document.getElementById('chat-toggle');
            
            chatContainer.classList.toggle('collapsed');
            
            if (chatContainer.classList.contains('collapsed')) {
                toggleButton.textContent = 'Show';
                isTyping = false;
            } else {
                toggleButton.textContent = 'Hide';
            }
        }
        
        function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();
            
            if (message && socket && socket.connected) {
                socket.emit('chat-message', { message: message });
                input.value = '';
            } else if (!socket || !socket.connected) {
                console.error('Not connected to server');
                alert('Not connected to server. Please refresh the page.');
            }
        }
        
        function addChatMessage(messageData) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            
            const time = new Date(messageData.timestamp).toLocaleTimeString();
            
            if (messageData.type === 'system') {
                messageElement.className = 'system-message';
                messageElement.textContent = `[${time}] ${messageData.message}`;
            } else {
                messageElement.className = 'user-message';
                messageElement.innerHTML = `<strong>[${time}] ${messageData.username}:</strong> ${messageData.message}`;
            }
            
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function updateBillboard(billboardId, imageData) {
            if (!billboardMeshes[billboardId]) return;
            
            if (imageData) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 384;
                    
                    ctx.drawImage(img, 0, 0, 512, 384);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    billboardMeshes[billboardId].material.map = texture;
                    billboardMeshes[billboardId].material.needsUpdate = true;
                };
                img.src = imageData;
            } else {
                billboardMeshes[billboardId].material.map = null;
                billboardMeshes[billboardId].material.color.setHex(0xffffff);
                billboardMeshes[billboardId].material.needsUpdate = true;
            }
        }
        
        function handleBillboardClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const billboardObjects = Object.values(billboardMeshes);
            const intersects = raycaster.intersectObjects(billboardObjects);
            
            if (intersects.length > 0) {
                const clickedBillboard = intersects[0].object;
                if (clickedBillboard.userData.billboardId) {
                    openUploadModal(clickedBillboard.userData.billboardId);
                }
            }
        }
        
        function openUploadModal(billboardId) {
            currentBillboardId = billboardId;
            document.getElementById('modal-title').textContent = 
                `Upload Image to ${billboardId === 'billboard1' ? 'Billboard 1' : 'Billboard 2'}`;
            document.getElementById('upload-modal').style.display = 'block';
            document.getElementById('modal-file-input').value = '';
        }
        
        function closeUploadModal() {
            document.getElementById('upload-modal').style.display = 'none';
            currentBillboardId = null;
        }
        
        function handleModalUpload() {
            if (!currentBillboardId) return;
            
            const fileInput = document.getElementById('modal-file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first');
                return;
            }
            
            if (file.size > 2 * 1024 * 1024) {
                alert('File size must be less than 2MB');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            formData.append('billboardId', currentBillboardId);
            
            const button = document.getElementById('modal-upload-btn');
            button.disabled = true;
            button.textContent = 'Uploading...';
            
            fetch('/upload-billboard', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeUploadModal();
                } else {
                    alert(data.error || 'Upload failed');
                }
            })
            .catch(error => {
                alert('Upload failed: ' + error.message);
            })
            .finally(() => {
                button.disabled = false;
                button.textContent = 'Upload';
            });
        }
        
        // Socket event handlers
        function setupSocketHandlers() {
            if (!socket) {
                console.error('Socket not initialized');
                return;
            }
            
            socket.on('connect', () => {
                console.log('Connected to server with ID:', socket.id);
                myUserId = socket.id;
                
                socket.emit('user-joined', {
                    username: username,
                    avatarType: selectedAvatar,
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 }
                });
            });
            
            socket.on('disconnect', () => {
                console.log('Disconnected from server');
            });
            
            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                alert('Failed to connect to server');
            });
            
            socket.on('init-data', (data) => {
                console.log('Received init data:', data);
                data.chatMessages.forEach(message => {
                    addChatMessage(message);
                });
                
                if (data.billboardImages.billboard1) {
                    updateBillboard('billboard1', data.billboardImages.billboard1);
                }
                if (data.billboardImages.billboard2) {
                    updateBillboard('billboard2', data.billboardImages.billboard2);
                }
            });
            
            socket.on('user-list-updated', (users) => {
                console.log('User list updated:', users);
                Object.keys(avatars).forEach(userId => {
                    if (!users[userId] || userId === myUserId) {
                        scene.remove(avatars[userId]);
                        if (avatarMixers[userId]) {
                            delete avatarMixers[userId];
                        }
                        delete avatars[userId];
                    }
                });
                
                Object.values(users).forEach(userData => {
                    if (userData.id !== myUserId) {
                        if (!avatars[userData.id]) {
                            avatars[userData.id] = createAvatar(userData);
                            scene.add(avatars[userData.id]);
                        } else {
                            avatars[userData.id].position.copy(userData.position);
                            avatars[userData.id].rotation.copy(userData.rotation);
                        }
                    }
                });
                
                document.getElementById('user-count').textContent = Object.keys(users).length;
            });
            
            socket.on('user-moved', (data) => {
                if (avatars[data.userId]) {
                    avatars[data.userId].position.copy(data.position);
                    avatars[data.userId].rotation.copy(data.rotation);
                }
            });
            
            socket.on('chat-message', (data) => {
                console.log('Chat message received:', data);
                addChatMessage(data);
            });
            
            socket.on('billboard-updated', (data) => {
                updateBillboard(data.billboardId, data.imageData);
            });
        }
        
        // Call this after scene is initialized
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Load skybox
            loadSkybox();
            
            // Improved lighting for better billboard visibility
            const ambientLight = new THREE.AmbientLight(0x404040, 1.8); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Light 2
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(50, 50, -50);
            directionalLight2.castShadow = false;
            directionalLight2.shadow.mapSize.width = 2048;
            directionalLight2.shadow.mapSize.height = 2048;
            scene.add(directionalLight2);
            
            // Create ground with texture
            createGround();
            
            // Create trees
            createTrees();
            
            // Create billboards
            createBillboards();
            
            // Create my avatar
            createMyAvatar();
            
            // Setup controls
            setupControls();
            
            // Setup socket handlers after scene is ready
            setupSocketHandlers();
            
            // Start render loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
