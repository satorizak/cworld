<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Multiuser Chat â€” Minimal Startup</title>

<style>
  html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;overflow:hidden}
  #startup{position:absolute;inset:0;background:white;display:flex;align-items:center;justify-content:center;z-index:30}
  #startup .box{padding:18px;border-radius:6px;box-shadow:0 8px 24px rgba(0,0,0,0.15)}
  #startup input,#startup select,#startup button{display:block;margin:8px 0;padding:8px;font-size:16px}
  #ui{position:absolute;left:8px;top:8px;z-index:40}
  #chat{position:absolute;left:0;top:0;width:20vw;min-width:180px;height:100%;background:rgba(255,255,255,0.9);z-index:35;display:flex;flex-direction:column}
  #chat #messages{flex:1;overflow:auto;padding:8px}
  #chat #input{display:flex;padding:8px;border-top:1px solid #ddd}
  #chat input{flex:1;padding:6px}
  #upload-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;padding:12px;border-radius:8px;z-index:60;display:none}
  #upload-modal input{display:block;margin:8px 0}
  canvas{display:block}
</style>
</head>
<body>

<!-- Startup -->
<div id="startup">
  <div class="box">
    <div style="font-weight:600;margin-bottom:8px">Join 3D World</div>
    <input id="username" placeholder="Enter username" />
    <select id="avatar-select">
      <!-- placeholder avatar options; each has data-scale to control initial scale -->
      <option value="avatars/robot.glb" data-scale="1">Robot</option>
      <option value="avatars/astronaut.glb" data-scale="1.2">Astronaut</option>
      <option value="avatars/duck.glb" data-scale="0.8">Duck</option>
      <option value="avatars/fish.glb" data-scale="1.5">Fish</option>
    </select>
    <button id="join">Join World</button>
  </div>
</div>

<!-- Chat panel (hidden until join) -->
<div id="chat" style="display:none">
  <div id="messages"></div>
  <div id="input">
    <input id="msg" placeholder="Say something..." />
    <button id="send">Send</button>
  </div>
</div>

<!-- Upload modal -->
<div id="upload-modal">
  <div id="upload-title">Upload image</div>
  <input id="upload-file" type="file" accept="image/*" />
  <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
    <button id="upload-do">Upload</button>
    <button id="upload-cancel">Cancel</button>
  </div>
</div>

<!-- Socket.IO client -->
<script src="/socket.io/socket.io.js"></script>
<!-- non-module Three.js + non-module GLTFLoader (exposes THREE.GLTFLoader) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ======= Client side multi-user code ======= */

let socket = null;
let scene, camera, renderer;
let myAvatar = null, myId = null;
let avatars = {}; // userId -> THREE.Group
let mixers = {};
const clock = new THREE.Clock();

const startup = document.getElementById('startup');
const joinBtn = document.getElementById('join');
const usernameInput = document.getElementById('username');
const avatarSelect = document.getElementById('avatar-select');

const chatPanel = document.getElementById('chat');
const messagesEl = document.getElementById('messages');
const msgInput = document.getElementById('msg');
const sendBtn = document.getElementById('send');

const uploadModal = document.getElementById('upload-modal');
const uploadFile = document.getElementById('upload-file');
const uploadDo = document.getElementById('upload-do');
const uploadCancel = document.getElementById('upload-cancel');

let currentUploadBillboard = null; // 'billboard1' or 'billboard2'

// basic scene init (called after join)
function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 6);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // lights
  scene.add(new THREE.AmbientLight(0x888888));
  const d = new THREE.DirectionalLight(0xffffff, 0.9);
  d.position.set(10, 20, 10);
  scene.add(d);

  // ground
  const g = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshLambertMaterial({color:0x3d8b37}));
  g.rotation.x = -Math.PI/2;
  scene.add(g);

  // trees (simple)
  for (let i=0;i<10;i++){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,1), new THREE.MeshLambertMaterial({color:0x8b5a2b}));
    const crown = new THREE.Mesh(new THREE.ConeGeometry(0.7,1.8), new THREE.MeshLambertMaterial({color:0x1b8b3a}));
    trunk.position.set((Math.random()-0.5)*40,0.5,(Math.random()-0.5)*40);
    crown.position.set(trunk.position.x,1.6,trunk.position.z);
    scene.add(trunk); scene.add(crown);
  }

  // billboards (two)
  const bbMat = new THREE.MeshLambertMaterial({color:0xffffff});
  const bb1 = new THREE.Mesh(new THREE.PlaneGeometry(6,4), bbMat.clone());
  bb1.position.set(-5,2,-5); bb1.userData.id='billboard1'; scene.add(bb1);
  const bb2 = new THREE.Mesh(new THREE.PlaneGeometry(6,4), bbMat.clone());
  bb2.position.set(5,2,-5); bb2.userData.id='billboard2'; scene.add(bb2);

  // raycaster click handler for uploads
  renderer.domElement.addEventListener('pointerdown', (e)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - rect.left)/rect.width)*2-1;
    const y = -((e.clientY - rect.top)/rect.height)*2+1;
    const r = new THREE.Raycaster();
    r.setFromCamera(new THREE.Vector2(x,y), camera);
    const hits = r.intersectObjects([bb1,bb2]);
    if (hits.length) {
      currentUploadBillboard = hits[0].object.userData.id;
      uploadModal.style.display = 'block';
    }
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
}

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  Object.values(mixers).forEach(m => m.update(dt));
  renderer.render(scene, camera);
}

/* Load avatar .glb via THREE.GLTFLoader (non-module loader attaches as THREE.GLTFLoader) */
function loadAvatarModel(path, scale=1, callback){
  try {
    const loader = new THREE.GLTFLoader();
    loader.load(path, gltf => {
      const model = gltf.scene;
      model.scale.set(scale,scale,scale);
      // center
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);
      // animations
      let mixer = null;
      if (gltf.animations && gltf.animations.length>0){
        mixer = new THREE.AnimationMixer(model);
        // try play first
        const action = mixer.clipAction(gltf.animations[0]);
        action.play();
      }
      callback(null, { model, mixer });
    }, undefined, err => {
      console.warn('GLB load err', err);
      callback(err);
    });
  } catch (e) {
    callback(e);
  }
}

/* UI & Socket wiring */

joinBtn.addEventListener('click', () => {
  const username = usernameInput.value.trim();
  if (!username) { alert('Enter username'); return; }
  const sel = avatarSelect.selectedOptions[0];
  const avatarPath = sel.value;
  const avatarScale = parseFloat(sel.dataset.scale || '1');

  // remove startup and show chat panel
  startup.remove();
  chatPanel.style.display = 'flex';

  // init scene & socket
  initScene();
  socket = io();

  // when socket connects send join
  socket.on('connect', ()=> {
    myId = socket.id;
    socket.emit('join', { username, avatarPath, scale: avatarScale });
  });

  socket.on('init', (data)=>{
    // chat history
    (data.chatHistory || []).forEach(addChatEntry);
    // billboards if any
    if (data.billboards){
      Object.keys(data.billboards).forEach(k => {
        if (data.billboards[k]){
          // emit as update
          applyBillboardToScene(k, data.billboards[k]);
        }
      });
    }
    // existing users
    if (data.users){
      Object.entries(data.users).forEach(([id,u])=>{
        if (id === myId) return;
        addRemoteUserToScene(id,u);
      });
    }
  });

  socket.on('user-list-updated', (usersMap) => {
    // remove disconnected
    Object.keys(avatars).forEach(id=>{
      if (!usersMap[id]) {
        if (avatars[id]) { scene.remove(avatars[id]); delete avatars[id]; }
        if (mixers[id]) delete mixers[id];
      }
    });
    // add/update
    Object.entries(usersMap).forEach(([id,u])=>{
      if (id === myId) return;
      if (!avatars[id]) addRemoteUserToScene(id,u);
      else {
        avatars[id].position.set(u.position.x,u.position.y,u.position.z);
        avatars[id].rotation.set(u.rotation.x,u.rotation.y,u.rotation.z);
      }
    });
    document.getElementById('messages') && (document.getElementById('messages').dataset.users = Object.keys(usersMap).length);
  });

  socket.on('user-moved', (data) => {
    const id = data.userId;
    if (avatars[id]) {
      avatars[id].position.set(data.position.x,data.position.y,data.position.z);
      avatars[id].rotation.set(data.rotation.x,data.rotation.y,data.rotation.z);
    }
  });

  socket.on('chat-message', (m) => addChatEntry(m));

  socket.on('updateBillboardsBatch', (map) => {
    Object.keys(map).forEach(k => applyBillboardToScene(k, map[k]));
  });

  socket.on('clearAll', () => {
    // clear billboards
    scene.traverse(o => {
      if (o.userData && (o.userData.id==='billboard1' || o.userData.id==='billboard2')){
        o.material.map = null;
        o.material.needsUpdate = true;
      }
    });
    // clear chat UI
    messagesEl.innerHTML = '';
  });

  // create my avatar locally (load and add to scene)
  loadAvatarModel(avatarPath, avatarScale, (err, res) => {
    if (err) {
      console.warn('avatar load failed, using fallback');
      myAvatar = createFallbackAvatar();
    } else {
      myAvatar = res.model;
      if (res.mixer) mixers[myId] = res.mixer;
    }
    myAvatar.position.set(0,0,0);
    scene.add(myAvatar);
  });
});

// helper: add remote user (loads their avatar model once)
function addRemoteUserToScene(id, userData){
  const avatarGroup = new THREE.Group();
  avatars[id] = avatarGroup;
  scene.add(avatarGroup);

  if (userData.avatarPath) {
    loadAvatarModel(userData.avatarPath, userData.scale || 1, (err,res)=>{
      let mesh = err ? createFallbackAvatar() : res.model;
      avatarGroup.add(mesh);
      if (res && res.mixer) mixers[id] = res.mixer;
    });
  } else {
    const fallback = createFallbackAvatar();
    avatarGroup.add(fallback);
  }
  avatarGroup.position.set(userData.position.x, userData.position.y, userData.position.z);
  avatarGroup.rotation.set(userData.rotation.x,userData.rotation.y,userData.rotation.z);
}

function createFallbackAvatar() {
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,1.5), new THREE.MeshLambertMaterial({color:0x44aaff}));
  body.position.y = 0.75;
  g.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshLambertMaterial({color:0xffe0bd}));
  head.position.y = 1.7;
  g.add(head);
  return g;
}

function addChatEntry(entry) {
  const div = document.createElement('div');
  if (entry.type === 'system') { div.className='system'; div.textContent = `[SYSTEM] ${entry.message}`; }
  else { div.textContent = `[${new Date(entry.timestamp).toLocaleTimeString()}] ${entry.username}: ${entry.message}`; }
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* chat send */
sendBtn.addEventListener('click', ()=>{
  const text = msgInput.value.trim();
  if (!text || !socket) return;
  socket.emit('chat-message', { message: text });
  msgInput.value = '';
});

/* Upload modal handlers */
uploadCancel.addEventListener('click', ()=> { uploadModal.style.display='none'; uploadFile.value=''; currentUploadBillboard=null; });
uploadDo.addEventListener('click', ()=>{
  const f = uploadFile.files[0];
  if (!f) { alert('Select file'); return; }
  if (f.size > 2*1024*1024) { alert('Max 2MB'); return; }

  const fd = new FormData();
  fd.append('image', f);
  fd.append('billboardId', currentUploadBillboard);
  fd.append('uploader', usernameInput.value || 'Anon');

  uploadDo.disabled = true;
  fetch('/upload-billboard', { method:'POST', body: fd })
    .then(r=>r.json())
    .then(j=>{
      if (!j.success) alert(j.error || 'Upload failed');
      uploadModal.style.display = 'none';
      uploadFile.value = '';
      currentUploadBillboard = null;
    })
    .catch(err=>{ alert('Upload failed'); console.error(err); })
    .finally(()=> uploadDo.disabled = false);
});

/* Apply billboard dataURL to scene (simple approach: find mesh by userData.id) */
function applyBillboardToScene(billboardId, dataURL) {
  scene.traverse(o=>{
    if (o.isMesh && (o.userData.id==='billboard1' || o.userData.id==='billboard2')) {
      if (o.userData.id === billboardId) {
        const img = new Image();
        img.onload = ()=> {
          const tex = new THREE.CanvasTexture(img);
          o.material.map = tex;
          o.material.needsUpdate = true;
        };
        img.src = dataURL;
      }
    }
  });
}

/* movement: simple WASD (no pointerlock) - send server updates periodically */
let keys = {};
window.addEventListener('keydown', e=> keys[e.code]=true);
window.addEventListener('keyup', e=> keys[e.code]=false);
setInterval(()=>{
  if (!myAvatar || !socket) return;
  const speed = 0.06;
  let moved=false;
  if (keys['KeyW']||keys['ArrowUp']) { myAvatar.position.z -= speed; moved=true; }
  if (keys['KeyS']||keys['ArrowDown']) { myAvatar.position.z += speed; moved=true; }
  if (keys['KeyA']||keys['ArrowLeft']) { myAvatar.position.x -= speed; moved=true; }
  if (keys['KeyD']||keys['ArrowRight']) { myAvatar.position.x += speed; moved=true; }
  if (moved) {
    socket.emit('move', { position: { x: myAvatar.position.x, y: myAvatar.position.y, z: myAvatar.position.z }, rotation: { x: myAvatar.rotation.x, y: myAvatar.rotation.y, z: myAvatar.rotation.z } });
  }
}, 100);

/* small helper: add simple user count/system message on connect (optional) */
</script>
</body>
</html>

