<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chat World</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåç</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 400px;
            height: 300px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
            pointer-events: all;
            transition: transform 0.3s ease;
        }

        #chat-container.hidden {
            transform: translateY(270px);
        }

        #chat-toggle {
            position: absolute;
            top: -40px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            font-size: 12px;
        }

        #chat-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #chat-messages {
            height: 220px;
            overflow-y: auto;
            color: white;
            font-size: 12px;
            margin-bottom: 10px;
            border: 1px solid #333;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
        }

        #chat-input {
            display: flex;
            gap: 5px;
        }

        #message-input {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
        }

        #send-button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #send-button:hover {
            background: #0056b3;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            pointer-events: all;
            font-size: 12px;
        }

        #controls h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        #controls p {
            margin: 3px 0;
            line-height: 1.2;
        }

        #upload-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            pointer-events: all;
            z-index: 2000;
            min-width: 400px;
            text-align: center;
        }

        #upload-modal h3 {
            margin-top: 0;
            color: #fff;
        }

        .file-input {
            margin: 15px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            border: 2px solid #444;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .upload-button, .cancel-button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .upload-button {
            background: #28a745;
            color: white;
        }

        .upload-button:hover {
            background: #1e7e34;
        }

        .upload-button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .cancel-button {
            background: #dc3545;
            color: white;
        }

        .cancel-button:hover {
            background: #c82333;
        }

        .system-message {
            color: #ffeb3b;
            font-style: italic;
        }

        .user-message {
            color: #ffffff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading 3D World...</div>
    
    <div id="ui" style="display: none;">
        <div id="controls">
            <h3>Controls</h3>
            <p>WASD / Arrow Keys: Move around</p>
            <p>Mouse: Look around</p>
            <p>Click billboards to upload images</p>
            <p>Users online: <span id="user-count">1</span></p>
        </div>

        <div id="upload-modal">
            <h3 id="modal-title">Upload Image to Billboard</h3>
            <p>Select an image (max 2MB):</p>
            <input type="file" id="modal-file-input" class="file-input" accept="image/*">
            <div class="modal-buttons">
                <button class="upload-button" id="modal-upload-btn">Upload</button>
                <button class="cancel-button" id="modal-cancel-btn">Cancel</button>
            </div>
        </div>

        <div id="chat-container">
            <button id="chat-toggle">Hide Chat</button>
            <div id="chat-messages"></div>
            <div id="chat-input">
                <input type="text" id="message-input" placeholder="Type your message..." maxlength="200">
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, socket;
        let avatars = {};
        let myAvatar = null;
        let myUserId = null;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let billboardMeshes = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentBillboardId = null;
        let cameraOffset = new THREE.Vector3(0, 2, 5); // Camera follows behind avatar
        
        // Initialize socket connection
        socket = io();
        
        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create trees
            createTrees();
            
            // Create billboards
            createBillboards();
            
            // Setup controls
            setupControls();
            
            // Start render loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
        }
        
        function createTrees() {
            for (let i = 0; i < 15; i++) {
                const tree = new THREE.Group();
                
                // Randomly choose tree type
                const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
                
                if (treeType === 'oak') {
                    // Oak tree - round leaves, thick trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    
                    // Multiple spherical leaf clusters for oak
                    const leafColors = [0x228B22, 0x32CD32, 0x006400];
                    const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                    
                    // Main leaf cluster
                    const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                    const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                    leaves1.position.y = 5.5;
                    leaves1.castShadow = true;
                    tree.add(leaves1);
                    
                    // Additional leaf clusters for fuller look
                    const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                    const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                    const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves2.position.set(-1.2, 4.8, 0.8);
                    leaves2.castShadow = true;
                    tree.add(leaves2);
                    
                    const leaves3 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                    leaves3.position.set(1.5, 5.2, -0.5);
                    leaves3.castShadow = true;
                    tree.add(leaves3);
                    
                } else {
                    // Pine tree - conical shape, thinner trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    tree.add(trunk);
                    
                    // Layered conical sections for pine tree
                    const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                    const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                    
                    // Bottom layer
                    const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                    const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                    cone1.position.y = 5.5;
                    cone1.castShadow = true;
                    tree.add(cone1);
                    
                    // Middle layer
                    const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                    const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                    cone2.position.y = 6.8;
                    cone2.castShadow = true;
                    tree.add(cone2);
                    
                    // Top layer
                    const coneGeometry3 = new THREE.ConeGeometry(1.3, 2);
                    const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                    const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                    cone3.position.y = 8;
                    cone3.castShadow = true;
                    tree.add(cone3);
                }
                
                // Random position (avoid center area)
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 80;
                    z = (Math.random() - 0.5) * 80;
                } while (Math.abs(x) < 15 && Math.abs(z) < 15);
                
                tree.position.set(x, 0, z);
                
                // Add slight random rotation for variety
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                scene.add(tree);
            }
        }
        
        function createBillboards() {
            // Billboard 1 (no support posts)
            const billboard1Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard1Material = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide // Show on both sides
            });
            // Disable backface culling and ensure proper lighting on both sides
            billboard1Material.transparent = false;
            const billboard1 = new THREE.Mesh(billboard1Geometry, billboard1Material);
            billboard1.position.set(-15, 5, 0);
            billboard1.castShadow = true;
            billboard1.receiveShadow = false;
            billboard1.userData = { billboardId: 'billboard1' }; // For raycasting
            billboardMeshes.billboard1 = billboard1;
            scene.add(billboard1);
            
            // Billboard 2 (no support posts)
            const billboard2Geometry = new THREE.PlaneGeometry(8, 6);
            const billboard2Material = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide // Show on both sides
            });
            // Disable backface culling and ensure proper lighting on both sides
            billboard2Material.transparent = false;
            const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);
            billboard2.position.set(15, 5, 0);
            billboard2.castShadow = true;
            billboard2.receiveShadow = false;
            billboard2.userData = { billboardId: 'billboard2' }; // For raycasting
            billboardMeshes.billboard2 = billboard2;
            scene.add(billboard2);
        }
        
        function createAvatar(userData) {
            const avatar = new THREE.Group();
            
            // Body (using cylinder instead of capsule for compatibility)
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: userData.color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            avatar.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.4);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;
            head.castShadow = true;
            avatar.add(head);
            
            // Username label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'white';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText(userData.username, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 3.5;
            label.scale.set(2, 0.5, 1);
            avatar.add(label);
            
            // Set position and make sure it's above ground
            avatar.position.set(userData.position.x, Math.max(0, userData.position.y), userData.position.z);
            avatar.rotation.copy(userData.rotation);
            
            console.log(`Created avatar for ${userData.username} at position:`, avatar.position);
            
            return avatar;
        }
        
        function setupControls() {
            // Keyboard controls - only when not typing in chat
            document.addEventListener('keydown', (event) => {
                // Don't move if typing in chat input
                if (document.activeElement.id === 'message-input' || document.activeElement.id === 'modal-file-input') {
                    return;
                }
                
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp': 
                        moveForward = true; 
                        break;
                    case 'KeyS':
                    case 'ArrowDown': 
                        moveBackward = true; 
                        break;
                    case 'KeyA':
                    case 'ArrowLeft': 
                        moveLeft = true; 
                        break;
                    case 'KeyD':
                    case 'ArrowRight': 
                        moveRight = true; 
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                // Don't move if typing in chat input
                if (document.activeElement.id === 'message-input' || document.activeElement.id === 'modal-file-input') {
                    return;
                }
                
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp': 
                        moveForward = false; 
                        break;
                    case 'KeyS':
                    case 'ArrowDown': 
                        moveBackward = false; 
                        break;
                    case 'KeyA':
                    case 'ArrowLeft': 
                        moveLeft = false; 
                        break;
                    case 'KeyD':
                    case 'ArrowRight': 
                        moveRight = false; 
                        break;
                }
            });
            
            // Mouse controls for camera and billboard clicking
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousedown', (event) => {
                if (event.target === renderer.domElement) {
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            document.addEventListener('mouseup', (event) => {
                if (isMouseDown && event.target === renderer.domElement) {
                    const deltaX = Math.abs(event.clientX - mouseX);
                    const deltaY = Math.abs(event.clientY - mouseY);
                    
                    // If mouse didn't move much, treat as click
                    if (deltaX < 5 && deltaY < 5) {
                        handleBillboardClick(event);
                    }
                }
                isMouseDown = false;
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    camera.rotation.y -= deltaX * 0.005;
                    camera.rotation.x -= deltaY * 0.005;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            // Modal controls
            document.getElementById('modal-upload-btn').addEventListener('click', handleModalUpload);
            document.getElementById('modal-cancel-btn').addEventListener('click', closeUploadModal);
            
            // Chat controls
            document.getElementById('send-button').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Chat toggle
            document.getElementById('chat-toggle').addEventListener('click', toggleChat);
        }
        
        function updateMovement() {
            if (!myAvatar) return;
            
            const speed = 0.2;
            velocity.set(0, 0, 0);
            
            if (moveForward) velocity.z += speed;  // Fixed direction
            if (moveBackward) velocity.z -= speed; // Fixed direction
            if (moveLeft) velocity.x += speed;
            if (moveRight) velocity.x -= speed;
            
            if (velocity.length() > 0) {
                // Move avatar based on camera's Y rotation
                const avatarDirection = new THREE.Vector3();
                avatarDirection.set(velocity.x, 0, velocity.z);
                avatarDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
                
                const oldPosition = myAvatar.position.clone();
                
                myAvatar.position.add(avatarDirection);
                myAvatar.position.y = 0; // Keep avatar on ground
                
                // Update camera to follow behind avatar
                updateCameraPosition();
                
                // Only send update if position actually changed significantly
                if (oldPosition.distanceTo(myAvatar.position) > 0.01) {
                    socket.emit('user-moved', {
                        position: {
                            x: myAvatar.position.x,
                            y: myAvatar.position.y,
                            z: myAvatar.position.z
                        },
                        rotation: {
                            x: myAvatar.rotation.x,
                            y: camera.rotation.y, // Use camera Y rotation for avatar facing
                            z: myAvatar.rotation.z
                        }
                    });
                }
            }
        }
        
        function updateCameraPosition() {
            if (!myAvatar) return;
            
            // Calculate camera position behind and above the avatar
            const cameraPosition = new THREE.Vector3();
            cameraPosition.copy(cameraOffset);
            cameraPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            cameraPosition.add(myAvatar.position);
            
            camera.position.copy(cameraPosition);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateMovement();
            
            renderer.render(scene, camera);
        }
        
        function toggleChat() {
            const chatContainer = document.getElementById('chat-container');
            const toggleButton = document.getElementById('chat-toggle');
            
            if (chatContainer.classList.contains('hidden')) {
                chatContainer.classList.remove('hidden');
                toggleButton.textContent = 'Hide Chat';
            } else {
                chatContainer.classList.add('hidden');
                toggleButton.textContent = 'Show Chat';
            }
        }
        
        function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();
            
            if (message) {
                socket.emit('chat-message', { message: message });
                input.value = '';
            }
        }
        
        function addChatMessage(messageData) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            
            const time = new Date(messageData.timestamp).toLocaleTimeString();
            
            if (messageData.type === 'system') {
                messageElement.className = 'system-message';
                messageElement.textContent = `[${time}] ${messageData.message}`;
            } else {
                messageElement.className = 'user-message';
                messageElement.innerHTML = `<strong>[${time}] ${messageData.username}:</strong> ${messageData.message}`;
            }
            
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function updateBillboard(billboardId, imageData) {
            if (!billboardMeshes[billboardId]) return;
            
            if (imageData) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 384;
                    
                    ctx.drawImage(img, 0, 0, 512, 384);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    billboardMeshes[billboardId].material.map = texture;
                    billboardMeshes[billboardId].material.needsUpdate = true;
                };
                img.src = imageData;
            } else {
                billboardMeshes[billboardId].material.map = null;
                billboardMeshes[billboardId].material.color.setHex(0xffffff);
                billboardMeshes[billboardId].material.needsUpdate = true;
            }
        }
        
        function handleBillboardClick(event) {
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check for billboard intersections
            const billboardObjects = Object.values(billboardMeshes);
            const intersects = raycaster.intersectObjects(billboardObjects);
            
            if (intersects.length > 0) {
                const clickedBillboard = intersects[0].object;
                if (clickedBillboard.userData.billboardId) {
                    openUploadModal(clickedBillboard.userData.billboardId);
                }
            }
        }
        
        function openUploadModal(billboardId) {
            currentBillboardId = billboardId;
            document.getElementById('modal-title').textContent = 
                `Upload Image to ${billboardId === 'billboard1' ? 'Billboard 1' : 'Billboard 2'}`;
            document.getElementById('upload-modal').style.display = 'block';
            document.getElementById('modal-file-input').value = '';
        }
        
        function closeUploadModal() {
            document.getElementById('upload-modal').style.display = 'none';
            currentBillboardId = null;
        }
        
        function handleModalUpload() {
            if (!currentBillboardId) return;
            
            const fileInput = document.getElementById('modal-file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first');
                return;
            }
            
            if (file.size > 2 * 1024 * 1024) {
                alert('File size must be less than 2MB');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            formData.append('billboardId', currentBillboardId);
            
            const button = document.getElementById('modal-upload-btn');
            button.disabled = true;
            button.textContent = 'Uploading...';
            
            fetch('/upload-billboard', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeUploadModal();
                } else {
                    alert(data.error || 'Upload failed');
                }
            })
            .catch(error => {
                alert('Upload failed: ' + error.message);
            })
            .finally(()
