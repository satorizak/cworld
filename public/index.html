<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chat World</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
        }
        #gameContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #87CEEB; /* Sky blue */
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            display: none; /* Initially hidden */
            z-index: 100;
        }
        #chatPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 300px;
            height: 400px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
            box-sizing: border-box;
            display: none; /* Initially hidden */
            flex-direction: column;
            color: white;
            z-index: 100;
        }
        #chatMessages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px;
        }
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 4px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background-color: transparent;
        }
        #chatInputContainer {
            display: flex;
        }
        #chatInput {
            flex-grow: 1;
            padding: 5px;
            border-radius: 5px;
            border: none;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            resize: none;
        }
        #sendButton {
            margin-left: 5px;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            background-color: #007BFF;
            color: white;
            cursor: pointer;
        }
        #playerList {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            color: white;
            display: none; /* Initially hidden */
            width: 150px;
            z-index: 100;
        }
        #playerList h3 {
            margin-top: 0;
            margin-bottom: 5px;
        }
        #playerNames {
            max-height: 200px;
            overflow-y: auto;
        }
        #playerNames::-webkit-scrollbar {
            width: 8px;
        }
        #playerNames::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 4px;
        }
        #playerNames::-webkit-scrollbar-track {
            background-color: transparent;
        }
        #loginPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 200;
            max-width: 400px;
            width: 90%;
        }
        #loginPanel h2 {
            margin-top: 0;
        }
        #loginPanel input, #loginPanel select {
            width: 90%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #joinButton {
            width: 90%;
            padding: 12px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        #joinButton:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        #loadingMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            display: none; /* Initially hidden */
        }
        #billboardUploadPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 200;
            display: none;
            max-width: 350px;
            width: 90%;
        }
        #billboardUploadPanel h3 {
            margin-top: 0;
        }
        #billboardUploadPanel input[type="file"] {
            display: block;
            margin: 15px auto;
        }
        #billboardUploadPanel button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
        }
        #uploadButton {
            background-color: #28a745;
            color: white;
        }
        #cancelUpload {
            background-color: #dc3545;
            color: white;
        }
        #chatToggle {
            position: absolute;
            bottom: 10px;
            right: 320px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 100;
        }
        .chat-expanded {
            width: 300px;
        }
        .chat-minimal {
            width: 150px;
        }
        .chat-collapsed {
            width: 50px;
            height: 50px;
        }
        
        /* D-Pad for mobile */
        #dpad {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 101;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(3, 50px);
            gap: 5px;
        }
        .dpad-button {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            user-select: none;
        }
        .dpad-button:active {
            background-color: rgba(255, 255, 255, 0.3);
        }
        #dpad-up { grid-area: 1 / 2 / 2 / 3; }
        #dpad-left { grid-area: 2 / 1 / 3 / 2; }
        #dpad-right { grid-area: 2 / 3 / 3 / 4; }
        #dpad-down { grid-area: 3 / 2 / 4 / 3; }
        @media (max-width: 768px) {
            #chatPanel {
                width: 90%;
                left: 5%;
                bottom: 100px;
                right: auto;
                height: 200px;
            }
            #dpad {
                display: grid;
            }
        }
    </style>
</head>
<body>

<div id="gameContainer"></div>

<div id="loginPanel">
    <h2>Welcome</h2>
    <input type="text" id="usernameInput" placeholder="Enter your username" autocomplete="off" maxlength="15">
    <select id="avatarSelect">
        <option value="default">Default Avatar</option>
        <option value="selena2">Selena</option>
        <option value="astronaut">Astronaut</option>
        <option value="martin2">Martin</option>
        <option value="cub">Cub</option>
    </select>
    <button id="joinButton" disabled>Join World</button>
</div>

<div id="loadingMessage">
    Loading assets... Please wait.
</div>

<div id="ui">
    </div>

<div id="playerList">
    <h3>Players Online: <span id="playerCount">0</span></h3>
    <div id="playerNames"></div>
</div>

<div id="billboardUploadPanel">
    <h3 id="billboardTitle">Upload Image</h3>
    <input type="file" id="imageFile" accept="image/*">
    <p>Max file size: 2MB</p>
    <button id="uploadButton">Upload</button>
    <button id="cancelUpload">Cancel</button>
</div>

<div id="chatToggle">Toggle Chat (Full)</div>

<div id="chatPanel" class="chat-expanded">
    <div id="chatMessages"></div>
    <div id="chatInputContainer">
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendButton">Send</button>
    </div>
</div>

<div id="dpad">
    <div id="dpad-up" class="dpad-button">↑</div>
    <div id="dpad-left" class="dpad-button">←</div>
    <div id="dpad-right" class="dpad-button">→</div>
    <div id="dpad-down" class="dpad-button">↓</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
    // Global variables
    let scene, camera, renderer, socket;
    let avatars = {};
    let myAvatar = null;
    let myUserId = null;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let billboardMeshes = {};
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let currentBillboardId = null;
    let isTyping = false;
    let selectedAvatar = 'default';
    let username = '';
    let gltfLoader = null;
    let avatarMixers = {};
    let clock = new THREE.Clock();

    const avatarScales = {
        'default': 1.0,
        'selena2': 1.0,
        'astronaut': 1.0,
        'martin2': 1.0,
        'cub': 1.0
    };
    const glbAvatars = {}; // Cache for loaded GLB models

    // Initialize GLTFLoader after scripts load
    function initGLTFLoader() {
        if (typeof THREE.GLTFLoader !== 'undefined') {
            gltfLoader = new THREE.GLTFLoader();
            console.log('GLTFLoader initialized successfully');
        } else {
            console.warn('GLTFLoader not available, using fallback avatars');
            gltfLoader = null;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const usernameInput = document.getElementById('usernameInput');
        const avatarSelect = document.getElementById('avatarSelect');
        const joinButton = document.getElementById('joinButton');

        usernameInput.addEventListener('input', () => {
            joinButton.disabled = usernameInput.value.trim() === '';
        });

        joinButton.addEventListener('click', () => {
            username = usernameInput.value.trim();
            selectedAvatar = avatarSelect.value;
            if (username) {
                document.getElementById('loginPanel').style.display = 'none';
                document.getElementById('loadingMessage').style.display = 'block';
                setTimeout(initializeWorld, 500);
            }
        });

        usernameInput.focus();
    });

    function initializeWorld() {
        initGLTFLoader();
        loadAllAvatars().then(() => {
            if (typeof io !== 'undefined') {
                socket = io();
                initScene();
                setupSocketHandlers();
            } else {
                alert('Socket.io not loaded. Please check your network connection.');
            }
        }).catch(error => {
            console.error('Failed to load avatars:', error);
            alert('Failed to load game assets. Please refresh.');
        });
    }

    function initScene() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 7, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameContainer').appendChild(renderer.domElement);

        // Add permanent objects to the scene
        loadPermanentObject('objects/pond.glb', new THREE.Vector3(20, 0, -10), null);
        loadPermanentObject('objects/gazebo.glb', new THREE.Vector3(-25, 0, 20), new THREE.Vector3(0, Math.PI / 4, 0));

        loadSkybox();
        createLighting();
        createGround();
        createTrees();
        createBillboards();
        createMyAvatar(); // My avatar is created first
        setupControls();
        
        // Show UI elements
        document.getElementById('loadingMessage').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('playerList').style.display = 'block';
        document.getElementById('chatPanel').style.display = 'flex';
        
        // Show D-Pad on small screens
        if (window.innerWidth <= 768) {
            document.getElementById('dpad').style.display = 'grid';
        }

        animate();
    }

    function createLighting() {
        const ambientLight = new THREE.AmbientLight(0x404040, 1.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight2.position.set(50, 50, -50);
        directionalLight2.castShadow = false;
        directionalLight2.shadow.mapSize.width = 2048;
        directionalLight2.shadow.mapSize.height = 2048;
        scene.add(directionalLight2);
    }

    function loadSkybox() {
        const skyboxImages = [
            'textures/skybox/px.jpg', 'textures/skybox/nx.jpg',
            'textures/skybox/py.jpg', 'textures/skybox/ny.jpg',
            'textures/skybox/pz.jpg', 'textures/skybox/nz.jpg'
        ];
        const loader = new THREE.CubeTextureLoader();
        loader.load(skyboxImages, texture => {
            scene.background = texture;
        }, undefined, error => {
            console.warn('Skybox could not be loaded, using default sky:', error);
        });
    }
    
    function createGround() {
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            'textures/ground_texture.jpg',
            (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                const groundMaterial = new THREE.MeshLambertMaterial({ map: texture });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
            },
            undefined,
            (error) => {
                console.warn('Ground texture could not be loaded, using default color:', error);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b37 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
            }
        );
    }

    function createTrees() {
        for (let i = 0; i < 15; i++) {
            const tree = new THREE.Group();
            
            // Randomly choose tree type
            const treeType = Math.random() > 0.5 ? 'oak' : 'pine';
            
            if (treeType === 'oak') {
                // Oak tree - round leaves, thick trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Multiple spherical leaf clusters for oak
                const leafColors = [0x228B22, 0x32CD32, 0x006400];
                const leafColor = leafColors[Math.floor(Math.random() * leafColors.length)];
                
                // Main leaf cluster
                const leavesGeometry1 = new THREE.SphereGeometry(2.5);
                const leavesMaterial1 = new THREE.MeshLambertMaterial({ color: leafColor });
                const leaves1 = new THREE.Mesh(leavesGeometry1, leavesMaterial1);
                leaves1.position.y = 5.5;
                leaves1.castShadow = true;
                tree.add(leaves1);
                
                // Additional leaf clusters for fuller look
                const leavesGeometry2 = new THREE.SphereGeometry(1.8);
                const leavesMaterial2 = new THREE.MeshLambertMaterial({ color: leafColor });
                const leaves2 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                leaves2.position.set(-1.2, 4.8, 0.8);
                leaves2.castShadow = true;
                tree.add(leaves2);
                
                const leaves3 = new THREE.Mesh(leavesGeometry2, leavesMaterial2);
                leaves3.position.set(1.5, 5.2, -0.5);
                leaves3.castShadow = true;
                tree.add(leaves3);
                
            } else {
                // Pine tree - conical shape, thinner trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.4, 5);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.5;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Layered conical sections for pine tree
                const pineColors = [0x228B22, 0x006400, 0x2F4F2F];
                const pineColor = pineColors[Math.floor(Math.random() * pineColors.length)];
                
                // Bottom layer
                const coneGeometry1 = new THREE.ConeGeometry(2.2, 3);
                const coneMaterial1 = new THREE.MeshLambertMaterial({ color: pineColor });
                const cone1 = new THREE.Mesh(coneGeometry1, coneMaterial1);
                cone1.position.y = 5.5;
                cone1.castShadow = true;
                tree.add(cone1);
                
                // Middle layer
                const coneGeometry2 = new THREE.ConeGeometry(1.8, 2.5);
                const coneMaterial2 = new THREE.MeshLambertMaterial({ color: pineColor });
                const cone2 = new THREE.Mesh(coneGeometry2, coneMaterial2);
                cone2.position.y = 6.8;
                cone2.castShadow = true;
                tree.add(cone2);
                
                // Top layer
                const coneGeometry3 = new THREE.ConeGeometry(1.3, 2);
                const coneMaterial3 = new THREE.MeshLambertMaterial({ color: pineColor });
                const cone3 = new THREE.Mesh(coneGeometry3, coneMaterial3);
                cone3.position.y = 8;
                cone3.castShadow = true;
                tree.add(cone3);
            }
            
            // Random position (avoid center area)
            let x, z;
            do {
                x = (Math.random() - 0.5) * 80;
                z = (Math.random() - 0.5) * 80;
            } while (Math.abs(x) < 15 && Math.abs(z) < 15);
            
            tree.position.set(x, 0, z);
            tree.rotation.y = Math.random() * Math.PI * 2;
            scene.add(tree);
        }
    }
    
    function createBillboards() {
        const billboard1Geometry = new THREE.PlaneGeometry(8, 6);
        const billboard1Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const billboard1 = new THREE.Mesh(billboard1Geometry, billboard1Material);
        billboard1.position.set(-15, 5, 0);
        billboard1.castShadow = true;
        billboard1.userData = { billboardId: 'billboard1' };
        billboardMeshes.billboard1 = billboard1;
        scene.add(billboard1);
        
        const billboard2Geometry = new THREE.PlaneGeometry(8, 6);
        const billboard2Material = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);
        billboard2.position.set(15, 5, 0);
        billboard2.castShadow = true;
        billboard2.userData = { billboardId: 'billboard2' };
        billboardMeshes.billboard2 = billboard2;
        scene.add(billboard2);
    }

    // New function to load permanent GLB objects
    function loadPermanentObject(objectPath, position, rotation) {
        if (!gltfLoader) {
            console.warn('GLTFLoader not available, cannot load object:', objectPath);
            return;
        }
        gltfLoader.load(
            objectPath,
            (gltf) => {
                const object = gltf.scene;
                object.position.copy(position);
                if (rotation) {
                    object.rotation.set(rotation.x, rotation.y, rotation.z);
                }
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scene.add(object);
                console.log('Object loaded successfully:', objectPath);
            },
            undefined,
            (error) => {
                console.error('Failed to load object:', objectPath, error);
            }
        );
    }

    // UPDATED: Function to load all avatars from GitHub into a cache at the start
    function loadAllAvatars() {
        const avatarTypes = Object.keys(avatarScales);
        const promises = avatarTypes.map(avatarType => {
            if (avatarType === 'default') return Promise.resolve(null);
            return new Promise((resolve, reject) => {
                if (!gltfLoader) {
                    console.warn('GLTFLoader not available, skipping GLB loading');
                    return resolve(null);
                }
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // IMPORTANT: Replace 'your-username' and 'your-repo' with your actual GitHub details
                // This is likely why you cannot see other users' GLB avatars.
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                const githubUrl = `https://raw.githubusercontent.com/satorizak/cworld/main/public/avatars/${avatarType}.glb`;
                gltfLoader.load(
                    githubUrl,
                    (gltf) => {
                        const avatar = gltf.scene;
                        const scaleMultiplier = avatarScales[avatarType] || 1.0;
                        const box = new THREE.Box3().setFromObject(avatar);
                        const size = box.getSize(new THREE.Vector3());
                        const maxSize = Math.max(size.x, size.y, size.z);
                        const targetHeight = 2.5;
                        const scale = (targetHeight / maxSize) * scaleMultiplier;
                        avatar.scale.set(scale, scale, scale);
                        
                        const newBox = new THREE.Box3().setFromObject(avatar);
                        const verticalOffset = (newBox.max.y - newBox.min.y) / 2;

                        avatar.rotation.y = Math.PI; 

                        avatar.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        glbAvatars[avatarType] = { gltf: gltf, avatar: avatar, verticalOffset: verticalOffset };
                        console.log(`GLB avatar ${avatarType} loaded successfully`);
                        resolve(gltf);
                    },
                    undefined,
                    (error) => {
                        console.error(`Failed to load GLB avatar ${avatarType}:`, error);
                        resolve(null);
                    }
                );
            });
        });
        return Promise.all(promises);
    }

    function createFallbackAvatar(color = 0x4CAF50) {
        const avatar = new THREE.Group();
        const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1;
        body.castShadow = true;
        avatar.add(body);
        const headGeometry = new THREE.SphereGeometry(0.4);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB3 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.4;
        head.castShadow = true;
        avatar.add(head);
        return avatar;
    }

    // UPDATED: Create my avatar using the cached GLB data
    function createMyAvatar() {
        const avatarType = selectedAvatar;
        const avatarGroup = new THREE.Group();
        let avatar;
        if (glbAvatars[avatarType]) {
            const glb = glbAvatars[avatarType].gltf;
            avatar = glb.scene.clone();
            if (glb.animations && glb.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(avatar);
                avatarMixers[myUserId] = mixer;
                const idleAnimation = glb.animations.find(anim =>
                    anim.name.toLowerCase().includes('idle') ||
                    anim.name.toLowerCase().includes('stand')
                );
                if (idleAnimation) {
                    const action = mixer.clipAction(idleAnimation);
                    action.play();
                }
            }
            avatarGroup.position.y = glbAvatars[avatarType].verticalOffset;
        } else {
            avatar = createFallbackAvatar();
            avatarGroup.position.y = 1.25;
        }
        avatarGroup.add(avatar);
        myAvatar = avatarGroup;
        myAvatar.position.x = 0;
        myAvatar.position.z = 0;
        scene.add(myAvatar);
        updateCameraPosition();
    }
    
    // UPDATED: Create other users' avatars using the cached GLB data
    function createAvatar(userData) {
        const avatarGroup = new THREE.Group();
        let avatar;
        const avatarType = userData.avatarType || 'default';

        if (glbAvatars[avatarType]) {
            const glb = glbAvatars[avatarType].gltf;
            avatar = glb.scene.clone();
            if (glb.animations && glb.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(avatar);
                avatarMixers[userData.id] = mixer;
                const idleAnimation = glb.animations.find(anim =>
                    anim.name.toLowerCase().includes('idle') ||
                    anim.name.toLowerCase().includes('stand')
                );
                if (idleAnimation) {
                    const action = mixer.clipAction(idleAnimation);
                    action.play();
                }
            }
            avatarGroup.position.y = glbAvatars[avatarType].verticalOffset;
        } else {
            avatar = createFallbackAvatar(userData.color);
            avatarGroup.position.y = 1.25;
        }
        
        avatarGroup.add(avatar);
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
        context.fillRect(0, 0, 256, 64);
        context.fillStyle = 'white';
        context.font = '24px Arial';
        context.textAlign = 'center';
        context.fillText(userData.username, 128, 40);
        const texture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
        const label = new THREE.Sprite(labelMaterial);
        label.position.y = 3.5;
        label.scale.set(2, 0.5, 1);
        avatarGroup.add(label);
        avatarGroup.position.set(userData.position.x, userData.position.y, userData.position.z);
        avatarGroup.rotation.copy(userData.rotation);
        return avatarGroup;
    }

    function setupControls() {
        const chatInput = document.getElementById('chatInput');
        if (chatInput) {
            chatInput.addEventListener('focus', () => { isTyping = true; });
            chatInput.addEventListener('blur', () => { isTyping = false; });
        }

        document.addEventListener('keydown', (event) => {
            if (isTyping) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp': moveForward = true; break;
                case 'KeyS':
                case 'ArrowDown': moveBackward = true; break;
                case 'KeyA':
                case 'ArrowLeft': moveLeft = true; break;
                case 'KeyD':
                case 'ArrowRight': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (isTyping) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp': moveForward = false; break;
                case 'KeyS':
                case 'ArrowDown': moveBackward = false; break;
                case 'KeyA':
                case 'ArrowLeft': moveLeft = false; break;
                case 'KeyD':
                case 'ArrowRight': moveRight = false; break;
            }
        });

        let isMouseDown = false;
        let mouseX = 0;
        document.addEventListener('mousedown', (event) => {
            if (event.target === renderer.domElement) {
                isMouseDown = true;
                mouseX = event.clientX;
            }
        });

        document.addEventListener('mouseup', (event) => {
            isMouseDown = false;
            if (event.target === renderer.domElement) {
                handleBillboardClick(event);
            }
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown && myAvatar) {
                const deltaX = event.clientX - mouseX;
                myAvatar.rotation.y -= deltaX * 0.005;
                updateCameraPosition();
                mouseX = event.clientX;
            }
        });

        document.getElementById('uploadButton').addEventListener('click', handleModalUpload);
        document.getElementById('cancelUpload').addEventListener('click', closeUploadModal);
        
        // RE-ADDED chat toggle functionality
        const chatToggle = document.getElementById('chatToggle');
        if (chatToggle) chatToggle.addEventListener('click', toggleChatView);

        const sendButton = document.getElementById('sendButton');
        if (sendButton) sendButton.addEventListener('click', sendMessage);
        if (chatInput) chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') sendMessage();
        });

        const dpadUp = document.getElementById('dpad-up');
        const dpadDown = document.getElementById('dpad-down');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');

        const handleTouchStart = (e, direction) => { 
            e.preventDefault();
            switch (direction) {
                case 'up': moveForward = true; break;
                case 'down': moveBackward = true; break;
                case 'left': moveLeft = true; break;
                case 'right': moveRight = true; break;
            }
        };
        const handleTouchEnd = (e, direction) => { 
            e.preventDefault();
            switch (direction) {
                case 'up': moveForward = false; break;
                case 'down': moveBackward = false; break;
                case 'left': moveLeft = false; break;
                case 'right': moveRight = false; break;
            }
        };

        if (dpadUp) dpadUp.addEventListener('touchstart', (e) => handleTouchStart(e, 'up'));
        if (dpadUp) dpadUp.addEventListener('touchend', (e) => handleTouchEnd(e, 'up'));
        if (dpadDown) dpadDown.addEventListener('touchstart', (e) => handleTouchStart(e, 'down'));
        if (dpadDown) dpadDown.addEventListener('touchend', (e) => handleTouchEnd(e, 'down'));
        if (dpadLeft) dpadLeft.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'));
        if (dpadLeft) dpadLeft.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'));
        if (dpadRight) dpadRight.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'));
        if (dpadRight) dpadRight.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'));
    }

    // RE-ADDED and CORRECTED: chat toggle view function
    function toggleChatView() {
        const chatPanel = document.getElementById('chatPanel');
        const chatToggle = document.getElementById('chatToggle');
        if (!chatPanel || !chatToggle) return;

        if (chatPanel.style.display === 'none' || chatPanel.classList.contains('chat-collapsed')) {
            chatPanel.style.display = 'flex';
            chatPanel.classList.remove('chat-collapsed');
            chatPanel.classList.add('chat-expanded');
            chatToggle.textContent = 'Toggle Chat';
        } else {
            chatPanel.style.display = 'none';
            chatPanel.classList.remove('chat-expanded');
            chatPanel.classList.add('chat-collapsed');
            chatToggle.textContent = 'Show Chat';
        }
    }
    
    // UPDATED: Corrected movement function for proper controls and better synchronization
    function updateMovement() {
        if (!myAvatar) return;
        const speed = 0.2;
        const oldPosition = myAvatar.position.clone();
        
        const rotationY = myAvatar.rotation.y;
        
        // Correct forward/backward vector
        const forward = new THREE.Vector3(
            Math.sin(rotationY), 0, Math.cos(rotationY)
        );
        
        // Correct left/right vector
        const right = new THREE.Vector3(
            Math.cos(rotationY), 0, -Math.sin(rotationY)
        );

        if (moveForward) {
            myAvatar.position.add(forward.clone().multiplyScalar(speed));
        }
        if (moveBackward) {
            myAvatar.position.sub(forward.clone().multiplyScalar(speed));
        }
        if (moveLeft) {
            myAvatar.position.sub(right.clone().multiplyScalar(speed));
        }
        if (moveRight) {
            myAvatar.position.add(right.clone().multiplyScalar(speed));
        }

        updateCameraPosition();

        if (oldPosition.distanceTo(myAvatar.position) > 0.01 && socket && socket.connected) {
            socket.emit('user-moved', {
                position: { x: myAvatar.position.x, y: myAvatar.position.y, z: myAvatar.position.z },
                rotation: { x: myAvatar.rotation.x, y: myAvatar.rotation.y, z: myAvatar.rotation.z }
            });
        }
    }
    
    function updateCameraPosition() {
        if (!myAvatar) return;
        const avatarPosition = myAvatar.position.clone();
        const avatarRotation = myAvatar.rotation.y;
        const cameraDistance = 5;
        const cameraHeight = 2;
        const cameraX = avatarPosition.x - Math.sin(avatarRotation) * cameraDistance;
        const cameraZ = avatarPosition.z - Math.cos(avatarRotation) * cameraDistance;
        const cameraY = avatarPosition.y + cameraHeight;
        camera.position.set(cameraX, cameraY, cameraZ);
        const lookAtPoint = new THREE.Vector3(avatarPosition.x, avatarPosition.y + 1.5, avatarPosition.z);
        camera.lookAt(lookAtPoint);
    }

    function animate() {
        requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        Object.values(avatarMixers).forEach(mixer => {
            if (mixer) mixer.update(deltaTime);
        });
        updateMovement();
        renderer.render(scene, camera);
    }

    function sendMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        if (message && socket && socket.connected) {
            socket.emit('chat-message', { message: message });
            input.value = '';
        } else if (!socket || !socket.connected) {
            alert('Not connected to server. Please refresh the page.');
        }
    }

    function addChatMessage(messageData) {
        const messagesDiv = document.getElementById('chatMessages');
        const messageElement = document.createElement('p');
        const time = new Date(messageData.timestamp).toLocaleTimeString();
        if (messageData.type === 'system') {
            messageElement.style.color = '#ffeb3b';
            messageElement.style.fontStyle = 'italic';
            messageElement.textContent = `[${time}] ${messageData.message}`;
        } else {
            messageElement.style.color = '#ffffff';
            messageElement.innerHTML = `<strong>[${time}] ${messageData.username}:</strong> ${messageData.message}`;
        }
        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function updateBillboard(billboardId, imageData) {
        if (!billboardMeshes[billboardId]) return;
        if (imageData) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 384;
                ctx.drawImage(img, 0, 0, 512, 384);
                const texture = new THREE.CanvasTexture(canvas);
                billboardMeshes[billboardId].material.map = texture;
                billboardMeshes[billboardId].material.needsUpdate = true;
            };
            img.src = imageData;
        } else {
            billboardMeshes[billboardId].material.map = null;
            billboardMeshes[billboardId].material.color.setHex(0xffffff);
            billboardMeshes[billboardId].material.needsUpdate = true;
        }
    }

    function handleBillboardClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const billboardObjects = Object.values(billboardMeshes);
        const intersects = raycaster.intersectObjects(billboardObjects);
        if (intersects.length > 0) {
            const clickedBillboard = intersects[0].object;
            if (clickedBillboard.userData.billboardId) {
                openUploadModal(clickedBillboard.userData.billboardId);
            }
        }
    }

    function openUploadModal(billboardId) {
        currentBillboardId = billboardId;
        document.getElementById('billboardTitle').textContent = `Upload Image to ${billboardId}`;
        document.getElementById('billboardUploadPanel').style.display = 'block';
        document.getElementById('imageFile').value = '';
    }

    function closeUploadModal() {
        document.getElementById('billboardUploadPanel').style.display = 'none';
        currentBillboardId = null;
    }

    function handleModalUpload() {
        if (!currentBillboardId) return;
        const fileInput = document.getElementById('imageFile');
        const file = fileInput.files[0];
        if (!file) {
            alert('Please select a file first.');
            return;
        }
        if (file.size > 2 * 1024 * 1024) {
            alert('File size must be less than 2MB.');
            return;
        }
        const formData = new FormData();
        formData.append('image', file);
        formData.append('billboardId', currentBillboardId);
        const button = document.getElementById('uploadButton');
        button.disabled = true;
        button.textContent = 'Uploading...';
        fetch('/upload-billboard', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                closeUploadModal();
            } else {
                alert(data.error || 'Upload failed');
            }
        })
        .catch(error => {
            alert('Upload failed: ' + error.message);
        })
        .finally(() => {
            button.disabled = false;
            button.textContent = 'Upload';
        });
    }

    function setupSocketHandlers() {
        if (!socket) return;
        socket.on('connect', () => {
            myUserId = socket.id;
            if (myAvatar) {
                const position = myAvatar.position;
                socket.emit('user-joined', {
                    username: username,
                    avatarType: selectedAvatar,
                    position: { x: position.x, y: position.y, z: position.z },
                    rotation: { x: myAvatar.rotation.x, y: myAvatar.rotation.y, z: myAvatar.rotation.z }
                });
            } else {
                socket.emit('user-joined', {
                    username: username,
                    avatarType: selectedAvatar,
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 }
                });
            }
        });
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });
        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            alert('Failed to connect to server');
        });
        socket.on('init-data', (data) => {
            data.chatMessages.forEach(message => addChatMessage(message));
            if (data.billboardImages.billboard1) updateBillboard('billboard1', data.billboardImages.billboard1);
            if (data.billboardImages.billboard2) updateBillboard('billboard2', data.billboardImages.billboard2);
        });
        socket.on('user-list-updated', (users) => {
            const playerNamesList = document.getElementById('playerNames');
            playerNamesList.innerHTML = '';
            
            Object.keys(avatars).forEach(userId => {
                if (!users[userId] || userId === myUserId) {
                    scene.remove(avatars[userId]);
                    if (avatarMixers[userId]) delete avatarMixers[userId];
                    delete avatars[userId];
                }
            });
            Object.values(users).forEach(userData => {
                const listItem = document.createElement('p');
                listItem.textContent = userData.username;
                playerNamesList.appendChild(listItem);
                
                if (userData.id !== myUserId) {
                    if (!avatars[userData.id]) {
                        avatars[userData.id] = createAvatar(userData);
                        scene.add(avatars[userData.id]);
                    } else {
                        avatars[userData.id].position.set(userData.position.x, userData.position.y, userData.position.z);
                        avatars[userData.id].rotation.copy(userData.rotation);
                    }
                }
            });
            document.getElementById('playerCount').textContent = Object.keys(users).length;
        });
        socket.on('user-moved', (data) => {
            if (avatars[data.userId]) {
                avatars[data.userId].position.copy(data.position);
                avatars[data.userId].rotation.copy(data.rotation);
            }
        });
        socket.on('chat-message', (data) => {
            addChatMessage(data);
        });
        socket.on('billboard-updated', (data) => {
            updateBillboard(data.billboardId, data.imageData);
        });
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
